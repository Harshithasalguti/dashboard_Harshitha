"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oauth4webapi";
exports.ids = ["vendor-chunks/oauth4webapi"];
exports.modules = {

/***/ "(action-browser)/./node_modules/oauth4webapi/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/oauth4webapi/build/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OperationProcessingError: () => (/* binding */ OperationProcessingError),\n/* harmony export */   UnsupportedOperationError: () => (/* binding */ UnsupportedOperationError),\n/* harmony export */   authorizationCodeGrantRequest: () => (/* binding */ authorizationCodeGrantRequest),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   clientCredentialsGrantRequest: () => (/* binding */ clientCredentialsGrantRequest),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   deviceAuthorizationRequest: () => (/* binding */ deviceAuthorizationRequest),\n/* harmony export */   deviceCodeGrantRequest: () => (/* binding */ deviceCodeGrantRequest),\n/* harmony export */   discoveryRequest: () => (/* binding */ discoveryRequest),\n/* harmony export */   expectNoNonce: () => (/* binding */ expectNoNonce),\n/* harmony export */   expectNoState: () => (/* binding */ expectNoState),\n/* harmony export */   experimentalCustomFetch: () => (/* binding */ experimentalCustomFetch),\n/* harmony export */   experimentalUseMtlsAlias: () => (/* binding */ experimentalUseMtlsAlias),\n/* harmony export */   experimental_customFetch: () => (/* binding */ experimental_customFetch),\n/* harmony export */   experimental_useMtlsAlias: () => (/* binding */ experimental_useMtlsAlias),\n/* harmony export */   experimental_validateDetachedSignatureResponse: () => (/* binding */ experimental_validateDetachedSignatureResponse),\n/* harmony export */   experimental_validateJwtAccessToken: () => (/* binding */ experimental_validateJwtAccessToken),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateRandomCodeVerifier: () => (/* binding */ generateRandomCodeVerifier),\n/* harmony export */   generateRandomNonce: () => (/* binding */ generateRandomNonce),\n/* harmony export */   generateRandomState: () => (/* binding */ generateRandomState),\n/* harmony export */   getValidatedIdTokenClaims: () => (/* binding */ getValidatedIdTokenClaims),\n/* harmony export */   introspectionRequest: () => (/* binding */ introspectionRequest),\n/* harmony export */   isOAuth2Error: () => (/* binding */ isOAuth2Error),\n/* harmony export */   issueRequestObject: () => (/* binding */ issueRequestObject),\n/* harmony export */   parseWwwAuthenticateChallenges: () => (/* binding */ parseWwwAuthenticateChallenges),\n/* harmony export */   processAuthorizationCodeOAuth2Response: () => (/* binding */ processAuthorizationCodeOAuth2Response),\n/* harmony export */   processAuthorizationCodeOpenIDResponse: () => (/* binding */ processAuthorizationCodeOpenIDResponse),\n/* harmony export */   processClientCredentialsResponse: () => (/* binding */ processClientCredentialsResponse),\n/* harmony export */   processDeviceAuthorizationResponse: () => (/* binding */ processDeviceAuthorizationResponse),\n/* harmony export */   processDeviceCodeResponse: () => (/* binding */ processDeviceCodeResponse),\n/* harmony export */   processDiscoveryResponse: () => (/* binding */ processDiscoveryResponse),\n/* harmony export */   processIntrospectionResponse: () => (/* binding */ processIntrospectionResponse),\n/* harmony export */   processPushedAuthorizationResponse: () => (/* binding */ processPushedAuthorizationResponse),\n/* harmony export */   processRefreshTokenResponse: () => (/* binding */ processRefreshTokenResponse),\n/* harmony export */   processRevocationResponse: () => (/* binding */ processRevocationResponse),\n/* harmony export */   processUserInfoResponse: () => (/* binding */ processUserInfoResponse),\n/* harmony export */   protectedResourceRequest: () => (/* binding */ protectedResourceRequest),\n/* harmony export */   pushedAuthorizationRequest: () => (/* binding */ pushedAuthorizationRequest),\n/* harmony export */   refreshTokenGrantRequest: () => (/* binding */ refreshTokenGrantRequest),\n/* harmony export */   revocationRequest: () => (/* binding */ revocationRequest),\n/* harmony export */   skipAuthTimeCheck: () => (/* binding */ skipAuthTimeCheck),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   userInfoRequest: () => (/* binding */ userInfoRequest),\n/* harmony export */   validateAuthResponse: () => (/* binding */ validateAuthResponse),\n/* harmony export */   validateJwtAuthResponse: () => (/* binding */ validateJwtAuthResponse)\n/* harmony export */ });\nlet USER_AGENT;\nif (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n    const NAME = \"oauth4webapi\";\n    const VERSION = \"v2.8.1\";\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n    if (input == null) {\n        return false;\n    }\n    try {\n        return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];\n    } catch  {\n        return false;\n    }\n}\nconst clockSkew = Symbol();\nconst clockTolerance = Symbol();\nconst experimental_customFetch = Symbol();\nconst experimentalCustomFetch = experimental_customFetch;\nconst experimental_useMtlsAlias = Symbol();\nconst experimentalUseMtlsAlias = experimental_useMtlsAlias;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === \"string\") {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n    if (input instanceof ArrayBuffer) {\n        input = new Uint8Array(input);\n    }\n    const arr = [];\n    for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction decodeBase64Url(input) {\n    try {\n        const binary = atob(input.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n        const bytes = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++){\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    } catch (cause) {\n        throw new OPE(\"The input to be decoded is not correctly encoded.\", {\n            cause\n        });\n    }\n}\nfunction b64u(input) {\n    if (typeof input === \"string\") {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass LRU {\n    constructor(maxSize){\n        this.cache = new Map();\n        this._cache = new Map();\n        this.maxSize = maxSize;\n    }\n    get(key) {\n        let v = this.cache.get(key);\n        if (v) {\n            return v;\n        }\n        if (v = this._cache.get(key)) {\n            this.update(key, v);\n            return v;\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n    }\n    set(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.set(key, value);\n        } else {\n            this.update(key, value);\n        }\n        return this;\n    }\n    delete(key) {\n        if (this.cache.has(key)) {\n            return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n            return this._cache.delete(key);\n        }\n        return false;\n    }\n    update(key, value) {\n        this.cache.set(key, value);\n        if (this.cache.size >= this.maxSize) {\n            this._cache = this.cache;\n            this.cache = new Map();\n        }\n    }\n}\nclass UnsupportedOperationError extends Error {\n    constructor(message){\n        super(message ?? \"operation not supported\");\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass OperationProcessingError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n    return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n    return isCryptoKey(key) && key.type === \"private\";\n}\nfunction isPublicKey(key) {\n    return isCryptoKey(key) && key.type === \"public\";\n}\nconst SUPPORTED_JWS_ALGS = [\n    \"PS256\",\n    \"ES256\",\n    \"RS256\",\n    \"PS384\",\n    \"ES384\",\n    \"RS384\",\n    \"PS512\",\n    \"ES512\",\n    \"RS512\",\n    \"EdDSA\"\n];\nfunction processDpopNonce(response) {\n    try {\n        if (response.headers.has(\"dpop-nonce\")) {\n            const url = new URL(response.url);\n            dpopNonces.set(url.origin, response.headers.get(\"dpop-nonce\"));\n        }\n    } finally{\n        return response;\n    }\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, \"\");\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== \"object\" || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (looseInstanceOf(input, Headers)) {\n        input = Object.fromEntries(input.entries());\n    }\n    const headers = new Headers(input);\n    if (USER_AGENT && !headers.has(\"user-agent\")) {\n        headers.set(\"user-agent\", USER_AGENT);\n    }\n    if (headers.has(\"authorization\")) {\n        throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n    }\n    if (headers.has(\"dpop\")) {\n        throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n    }\n    return headers;\n}\nfunction signal(value) {\n    if (typeof value === \"function\") {\n        value = value();\n    }\n    if (!(value instanceof AbortSignal)) {\n        throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n    }\n    return value;\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n    if (!(issuerIdentifier instanceof URL)) {\n        throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n    }\n    if (issuerIdentifier.protocol !== \"https:\" && issuerIdentifier.protocol !== \"http:\") {\n        throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n    }\n    const url = new URL(issuerIdentifier.href);\n    switch(options?.algorithm){\n        case undefined:\n        case \"oidc\":\n            url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace(\"//\", \"/\");\n            break;\n        case \"oauth2\":\n            if (url.pathname === \"/\") {\n                url.pathname = `.well-known/oauth-authorization-server`;\n            } else {\n                url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace(\"//\", \"/\");\n            }\n            break;\n        default:\n            throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n    }\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nfunction validateString(input) {\n    return typeof input === \"string\" && input.length !== 0;\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    if (!(expectedIssuerIdentifier instanceof URL)) {\n        throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.issuer)) {\n        throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n    }\n    if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n        throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n    }\n    return json;\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n    return randomBytes();\n}\nfunction generateRandomState() {\n    return randomBytes();\n}\nfunction generateRandomNonce() {\n    return randomBytes();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return {\n            key: input\n        };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined && !validateString(input.kid)) {\n        throw new TypeError('\"kid\" must be a non-empty string');\n    }\n    return {\n        key: input.key,\n        kid: input.kid\n    };\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/%20/g, \"+\");\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n    const username = formUrlEncode(clientId);\n    const password = formUrlEncode(clientSecret);\n    const credentials = btoa(`${username}:${password}`);\n    return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"PS256\";\n        case \"SHA-384\":\n            return \"PS384\";\n        case \"SHA-512\":\n            return \"PS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction rsAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"RS256\";\n        case \"SHA-384\":\n            return \"RS384\";\n        case \"SHA-512\":\n            return \"RS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction esAlg(key) {\n    switch(key.algorithm.namedCurve){\n        case \"P-256\":\n            return \"ES256\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-521\":\n            return \"ES512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\");\n    }\n}\nfunction keyToJws(key) {\n    switch(key.algorithm.name){\n        case \"RSA-PSS\":\n            return psAlg(key);\n        case \"RSASSA-PKCS1-v1_5\":\n            return rsAlg(key);\n        case \"ECDSA\":\n            return esAlg(key);\n        case \"Ed25519\":\n        case \"Ed448\":\n            return \"EdDSA\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\");\n    }\n}\nfunction getClockSkew(client) {\n    if (client && clockSkew in client) {\n        if (Number.isFinite(client[clockSkew])) {\n            return client[clockSkew];\n        }\n    }\n    return 0;\n}\nfunction getClockTolerance(client) {\n    if (client && clockTolerance in client) {\n        const tolerance = client[clockTolerance];\n        if (Number.isFinite(tolerance) && Math.sign(tolerance) !== -1) {\n            return tolerance;\n        }\n    }\n    return 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: [\n            as.issuer,\n            as.token_endpoint\n        ],\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id\n    };\n}\nasync function privateKeyJwt(as, client, key, kid) {\n    return jwt({\n        alg: keyToJws(key),\n        kid\n    }, clientAssertion(as, client), key);\n}\nfunction assertAs(as) {\n    if (typeof as !== \"object\" || as === null) {\n        throw new TypeError('\"as\" must be an object');\n    }\n    if (!validateString(as.issuer)) {\n        throw new TypeError('\"as.issuer\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClient(client) {\n    if (typeof client !== \"object\" || client === null) {\n        throw new TypeError('\"client\" must be an object');\n    }\n    if (!validateString(client.client_id)) {\n        throw new TypeError('\"client.client_id\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClientSecret(clientSecret) {\n    if (!validateString(clientSecret)) {\n        throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n    }\n    return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n    if (clientPrivateKey !== undefined) {\n        throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n    if (clientSecret !== undefined) {\n        throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n    body.delete(\"client_secret\");\n    body.delete(\"client_assertion_type\");\n    body.delete(\"client_assertion\");\n    switch(client.token_endpoint_auth_method){\n        case undefined:\n        case \"client_secret_basic\":\n            {\n                assertNoClientPrivateKey(\"client_secret_basic\", clientPrivateKey);\n                headers.set(\"authorization\", clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n                break;\n            }\n        case \"client_secret_post\":\n            {\n                assertNoClientPrivateKey(\"client_secret_post\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_secret\", assertClientSecret(client.client_secret));\n                break;\n            }\n        case \"private_key_jwt\":\n            {\n                assertNoClientSecret(\"private_key_jwt\", client.client_secret);\n                if (clientPrivateKey === undefined) {\n                    throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n                }\n                const { key, kid } = getKeyAndKid(clientPrivateKey);\n                if (!isPrivateKey(key)) {\n                    throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n                }\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                body.set(\"client_assertion\", await privateKeyJwt(as, client, key, kid));\n                break;\n            }\n        case \"tls_client_auth\":\n        case \"self_signed_tls_client_auth\":\n        case \"none\":\n            {\n                assertNoClientSecret(client.token_endpoint_auth_method, client.client_secret);\n                assertNoClientPrivateKey(client.token_endpoint_auth_method, clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                break;\n            }\n        default:\n            throw new UnsupportedOperationError(\"unsupported client token_endpoint_auth_method\");\n    }\n}\nasync function jwt(header, claimsSet, key) {\n    if (!key.usages.includes(\"sign\")) {\n        throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(claimsSet)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nasync function issueRequestObject(as, client, parameters, privateKey) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    if (!isPrivateKey(key)) {\n        throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n    }\n    parameters.set(\"client_id\", client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id\n    };\n    let resource;\n    if (parameters.has(\"resource\") && (resource = parameters.getAll(\"resource\")) && resource.length > 1) {\n        claims.resource = resource;\n    }\n    if (parameters.has(\"claims\")) {\n        const value = parameters.get(\"claims\");\n        if (value === \"[object Object]\") {\n            throw new OPE('\"claims\" parameter must be passed as a UTF-8 encoded JSON');\n        }\n        try {\n            claims.claims = JSON.parse(value);\n        } catch (cause) {\n            throw new OPE('failed to parse the \"claims\" parameter as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(claims.claims)) {\n            throw new OPE('\"claims\" parameter must be a top level object');\n        }\n    }\n    return jwt({\n        alg: keyToJws(key),\n        typ: \"oauth-authz-req+jwt\",\n        kid\n    }, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n    const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n    if (!isPrivateKey(privateKey)) {\n        throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n    }\n    if (!isPublicKey(publicKey)) {\n        throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n    }\n    if (nonce !== undefined && !validateString(nonce)) {\n        throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n    }\n    if (!publicKey.extractable) {\n        throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n    }\n    const now = epochTime() + clockSkew;\n    const proof = await jwt({\n        alg: keyToJws(privateKey),\n        typ: \"dpop+jwt\",\n        jwk: await publicJwk(publicKey)\n    }, {\n        iat: now,\n        jti: randomBytes(),\n        htm,\n        nonce,\n        htu: `${url.origin}${url.pathname}`,\n        ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : undefined\n    }, privateKey);\n    headers.set(\"dpop\", proof);\n}\nlet jwkCache;\nasync function publicJwk(key) {\n    jwkCache || (jwkCache = new WeakMap());\n    if (jwkCache.has(key)) {\n        return jwkCache.get(key);\n    }\n    const { kty, e, n, x, y, crv } = await crypto.subtle.exportKey(\"jwk\", key);\n    const jwk = {\n        kty,\n        e,\n        n,\n        x,\n        y,\n        crv\n    };\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nfunction validateEndpoint(value, endpoint, options) {\n    if (typeof value !== \"string\") {\n        if (options?.[experimental_useMtlsAlias]) {\n            throw new TypeError(`\"as.mtls_endpoint_aliases.${endpoint}\" must be a string`);\n        } else {\n            throw new TypeError(`\"as.${endpoint}\" must be a string`);\n        }\n    }\n    return new URL(value);\n}\nfunction resolveEndpoint(as, endpoint, options) {\n    if (options?.[experimental_useMtlsAlias] && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, options);\n    }\n    return validateEndpoint(as[endpoint], endpoint);\n}\nasync function pushedAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"pushed_authorization_request_endpoint\", options);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nfunction isOAuth2Error(input) {\n    const value = input;\n    if (typeof value !== \"object\" || Array.isArray(value) || value === null) {\n        return false;\n    }\n    return value.error !== undefined;\n}\nfunction unquote(value) {\n    if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n        return value.slice(1, -1);\n    }\n    return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n    const arr = params.split(SPLIT_REGEXP).slice(1);\n    if (!arr.length) {\n        return {\n            scheme: scheme.toLowerCase(),\n            parameters: {}\n        };\n    }\n    arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, \"\");\n    const parameters = {};\n    for(let i = 1; i < arr.length; i += 2){\n        const idx = i;\n        if (arr[idx][0] === '\"') {\n            while(arr[idx].slice(-1) !== '\"' && ++i < arr.length){\n                arr[idx] += arr[i];\n            }\n        }\n        const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, \"\").toLowerCase();\n        parameters[key] = unquote(arr[idx]);\n    }\n    return {\n        scheme: scheme.toLowerCase(),\n        parameters\n    };\n}\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (!response.headers.has(\"www-authenticate\")) {\n        return undefined;\n    }\n    const header = response.headers.get(\"www-authenticate\");\n    const result = [];\n    for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)){\n        result.push([\n            scheme,\n            index\n        ]);\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    const challenges = result.map(([scheme, indexOf], i, others)=>{\n        const next = others[i + 1];\n        let parameters;\n        if (next) {\n            parameters = header.slice(indexOf, next[1]);\n        } else {\n            parameters = header.slice(indexOf);\n        }\n        return wwwAuth(scheme, parameters);\n    });\n    return challenges;\n}\nasync function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 201) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.request_uri)) {\n        throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    return json;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    if (!validateString(accessToken)) {\n        throw new TypeError('\"accessToken\" must be a non-empty string');\n    }\n    if (!(url instanceof URL)) {\n        throw new TypeError('\"url\" must be an instance of URL');\n    }\n    headers = prepareHeaders(headers);\n    if (options?.DPoP === undefined) {\n        headers.set(\"authorization\", `Bearer ${accessToken}`);\n    } else {\n        await dpopProofJwt(headers, options.DPoP, url, \"GET\", getClockSkew({\n            [clockSkew]: options?.[clockSkew]\n        }), accessToken);\n        headers.set(\"authorization\", `DPoP ${accessToken}`);\n    }\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"userinfo_endpoint\", options);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set(\"accept\", \"application/jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n        headers.append(\"accept\", \"application/jwt\");\n    }\n    return protectedResourceRequest(accessToken, \"GET\", url, headers, null, {\n        ...options,\n        [clockSkew]: getClockSkew(client)\n    });\n}\nlet jwksCache;\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(alg);\n    let jwks;\n    let age;\n    jwksCache || (jwksCache = new WeakMap());\n    if (jwksCache.has(as)) {\n        ;\n        ({ jwks, age } = jwksCache.get(as));\n        if (age >= 300) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    } else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        jwksCache.set(as, {\n            jwks,\n            iat: epochTime(),\n            get age () {\n                return epochTime() - this.iat;\n            }\n        });\n    }\n    let kty;\n    switch(alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            kty = \"RSA\";\n            break;\n        case \"ES\":\n            kty = \"EC\";\n            break;\n        case \"Ed\":\n            kty = \"OKP\";\n            break;\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const candidates = jwks.keys.filter((jwk)=>{\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== \"sig\") {\n            return false;\n        }\n        if (jwk.key_ops?.includes(\"verify\") === false) {\n            return false;\n        }\n        switch(true){\n            case alg === \"ES256\" && jwk.crv !== \"P-256\":\n            case alg === \"ES384\" && jwk.crv !== \"P-384\":\n            case alg === \"ES512\" && jwk.crv !== \"P-521\":\n            case alg === \"EdDSA\" && !(jwk.crv === \"Ed25519\" || jwk.crv === \"Ed448\"):\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw new OPE(\"error when selecting a JWT verification key, no applicable keys found\");\n    } else if (length !== 1) {\n        throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== \"public\") {\n        throw new OPE(\"jwks_uri must only contain public keys\");\n    }\n    return key;\n}\nconst skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n    return response.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as, client, expectedSubject, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as.issuer));\n        json = claims;\n    } else {\n        if (client.userinfo_signed_response_alg) {\n            throw new OPE(\"JWT UserInfo Response expected\");\n        }\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.sub)) {\n        throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n    }\n    switch(expectedSubject){\n        case skipSubjectCheck:\n            break;\n        default:\n            if (!validateString(expectedSubject)) {\n                throw new OPE('\"expectedSubject\" must be a non-empty string');\n            }\n            if (json.sub !== expectedSubject) {\n                throw new OPE('unexpected \"response\" body \"sub\" value');\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n    headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n    const url = resolveEndpoint(as, \"token_endpoint\", options);\n    parameters.set(\"grant_type\", grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, parameters, headers, options);\n}\nasync function refreshTokenGrantRequest(as, client, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(refreshToken)) {\n        throw new TypeError('\"refreshToken\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"refresh_token\", refreshToken);\n    return tokenEndpointRequest(as, client, \"refresh_token\", parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nfunction getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n    }\n    return claims;\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Token Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.access_token)) {\n        throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n    }\n    if (!validateString(json.token_type)) {\n        throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n    }\n    json.token_type = json.token_type.toLowerCase();\n    if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n        throw new UnsupportedOperationError(\"unsupported `token_type` value\");\n    }\n    if (json.expires_in !== undefined && (typeof json.expires_in !== \"number\" || json.expires_in <= 0)) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (!ignoreRefreshToken && json.refresh_token !== undefined && !validateString(json.refresh_token)) {\n        throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n    }\n    if (json.scope !== undefined && typeof json.scope !== \"string\") {\n        throw new OPE('\"response\" body \"scope\" property must be a string');\n    }\n    if (!ignoreIdToken) {\n        if (json.id_token !== undefined && !validateString(json.id_token)) {\n            throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n        }\n        if (json.id_token) {\n            const { claims } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n                \"aud\",\n                \"exp\",\n                \"iat\",\n                \"iss\",\n                \"sub\"\n            ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n            if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n                throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n            }\n            if (client.require_auth_time && typeof claims.auth_time !== \"number\") {\n                throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n            }\n            idTokenClaims.set(json, claims);\n        }\n    }\n    return json;\n}\nasync function processRefreshTokenResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n        }\n    } else if (result.claims.aud !== expected) {\n        throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n    return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(expected, result);\n    }\n    return result;\n}\nfunction validateIssuer(expected, result) {\n    if (result.claims.iss !== expected) {\n        throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nasync function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n    }\n    if (!validateString(redirectUri)) {\n        throw new TypeError('\"redirectUri\" must be a non-empty string');\n    }\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    const code = getURLSearchParameter(callbackParameters, \"code\");\n    if (!code) {\n        throw new OPE('no authorization code in \"callbackParameters\"');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"redirect_uri\", redirectUri);\n    parameters.set(\"code_verifier\", codeVerifier);\n    parameters.set(\"code\", code);\n    return tokenEndpointRequest(as, client, \"authorization_code\", parameters, options);\n}\nconst jwtClaimNames = {\n    aud: \"audience\",\n    c_hash: \"code hash\",\n    client_id: \"client id\",\n    exp: \"expiration time\",\n    iat: \"issued at\",\n    iss: \"issuer\",\n    jti: \"jwt id\",\n    nonce: \"nonce\",\n    s_hash: \"state hash\",\n    sub: \"subject\",\n    ath: \"access token hash\",\n    htm: \"http method\",\n    htu: \"http uri\",\n    cnf: \"confirmation\"\n};\nfunction validatePresence(required, result) {\n    for (const claim of required){\n        if (result.claims[claim] === undefined) {\n            throw new OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`);\n        }\n    }\n    return result;\n}\nconst expectNoNonce = Symbol();\nconst skipAuthTimeCheck = Symbol();\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n    const result = await processGenericAccessTokenResponse(as, client, response);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!validateString(result.id_token)) {\n        throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    const claims = getValidatedIdTokenClaims(result);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    switch(expectedNonce){\n        case undefined:\n        case expectNoNonce:\n            if (claims.nonce !== undefined) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n            break;\n        default:\n            if (!validateString(expectedNonce)) {\n                throw new TypeError('\"expectedNonce\" must be a non-empty string');\n            }\n            if (claims.nonce === undefined) {\n                throw new OPE('ID Token \"nonce\" claim missing');\n            }\n            if (claims.nonce !== expectedNonce) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (result.id_token !== undefined) {\n        if (typeof result.id_token === \"string\" && result.id_token.length) {\n            throw new OPE(\"Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing\");\n        }\n        delete result.id_token;\n    }\n    return result;\n}\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== \"string\" || normalizeTyp(result.header.typ) !== expected) {\n        throw new OPE('unexpected JWT \"typ\" header parameter value');\n    }\n    return result;\n}\nasync function clientCredentialsGrantRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, \"client_credentials\", new URLSearchParams(parameters), options);\n}\nasync function processClientCredentialsResponse(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    return result;\n}\nasync function revocationRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, \"revocation_endpoint\", options);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete(\"accept\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processRevocationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n    }\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw new TypeError('\"response\" body has been used already');\n    }\n}\nasync function introspectionRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, \"introspection_endpoint\", options);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set(\"accept\", \"application/token-introspection+jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processIntrospectionResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/token-introspection+jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(checkJwtType.bind(undefined, \"token-introspection+jwt\")).then(validatePresence.bind(undefined, [\n            \"aud\",\n            \"iat\",\n            \"iss\"\n        ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n        json = claims.token_introspection;\n        if (!isJsonObject(json)) {\n            throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n        }\n    } else {\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(json)) {\n            throw new OPE('\"response\" body must be a top level object');\n        }\n    }\n    if (typeof json.active !== \"boolean\") {\n        throw new OPE('\"response\" body \"active\" property must be a boolean');\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, \"jwks_uri\");\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwk-set+json\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!Array.isArray(json.keys)) {\n        throw new OPE('\"response\" body \"keys\" property must be an array');\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n    }\n    return json;\n}\nasync function handleOAuthBodyError(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        try {\n            const json = await response.json();\n            if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n                if (json.error_description !== undefined && typeof json.error_description !== \"string\") {\n                    delete json.error_description;\n                }\n                if (json.error_uri !== undefined && typeof json.error_uri !== \"string\") {\n                    delete json.error_uri;\n                }\n                if (json.algs !== undefined && typeof json.algs !== \"string\") {\n                    delete json.algs;\n                }\n                if (json.scope !== undefined && typeof json.scope !== \"string\") {\n                    delete json.scope;\n                }\n                return json;\n            }\n        } catch  {}\n    }\n    return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n    if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n    }\n    return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n    if (typeof algorithm.modulusLength !== \"number\" || algorithm.modulusLength < 2048) {\n        throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n    }\n}\nfunction ecdsaHashName(namedCurve) {\n    switch(namedCurve){\n        case \"P-256\":\n            return \"SHA-256\";\n        case \"P-384\":\n            return \"SHA-384\";\n        case \"P-521\":\n            return \"SHA-512\";\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nfunction keyToSubtle(key) {\n    switch(key.algorithm.name){\n        case \"ECDSA\":\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key.algorithm.namedCurve)\n            };\n        case \"RSA-PSS\":\n            {\n                checkRsaKeyAlgorithm(key.algorithm);\n                switch(key.algorithm.hash.name){\n                    case \"SHA-256\":\n                    case \"SHA-384\":\n                    case \"SHA-512\":\n                        return {\n                            name: key.algorithm.name,\n                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n                        };\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            checkRsaKeyAlgorithm(key.algorithm);\n            return key.algorithm.name;\n        case \"Ed448\":\n        case \"Ed25519\":\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance) {\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(\".\");\n    if (length === 5) {\n        throw new UnsupportedOperationError(\"JWE structure JWTs are not supported\");\n    }\n    if (length !== 3) {\n        throw new OPE(\"Invalid JWT\");\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Header body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(header)) {\n        throw new OPE(\"JWT Header must be a top level object\");\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new OPE('unexpected JWT \"crit\" header parameter');\n    }\n    const signature = b64u(encodedSignature);\n    let key;\n    if (getKey !== noSignatureCheck) {\n        key = await getKey(header);\n        const input = `${protectedHeader}.${payload}`;\n        const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n        if (!verified) {\n            throw new OPE(\"JWT signature verification failed\");\n        }\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(claims)) {\n        throw new OPE(\"JWT Payload must be a top level object\");\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== \"number\") {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== \"number\") {\n            throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== \"string\") {\n            throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== \"number\") {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n        }\n    }\n    return {\n        header,\n        claims,\n        signature,\n        key\n    };\n}\nasync function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    const response = getURLSearchParameter(parameters, \"response\");\n    if (!response) {\n        throw new OPE('\"parameters\" does not contain a JARM response');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const { claims } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n        \"aud\",\n        \"exp\",\n        \"iss\"\n    ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)){\n        if (typeof value === \"string\" && key !== \"aud\") {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(alg, data, key) {\n    let algorithm;\n    switch(alg){\n        case \"RS256\":\n        case \"PS256\":\n        case \"ES256\":\n            algorithm = \"SHA-256\";\n            break;\n        case \"RS384\":\n        case \"PS384\":\n        case \"ES384\":\n            algorithm = \"SHA-384\";\n            break;\n        case \"RS512\":\n        case \"PS512\":\n        case \"ES512\":\n            algorithm = \"SHA-512\";\n            break;\n        case \"EdDSA\":\n            if (key.algorithm.name === \"Ed25519\") {\n                algorithm = \"SHA-512\";\n                break;\n            }\n            throw new UnsupportedOperationError();\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const digest = await crypto.subtle.digest(algorithm, buf(data));\n    return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, alg, key) {\n    const expected = await idTokenHash(alg, data, key);\n    return actual === expected;\n}\nasync function experimental_validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        if (!parameters.hash.length) {\n            throw new TypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters');\n        }\n        parameters = new URLSearchParams(parameters.hash.slice(1));\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams');\n    }\n    parameters = new URLSearchParams(parameters);\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    parameters.delete(\"id_token\");\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new TypeError('\"expectedState\" must be a non-empty string');\n            }\n    }\n    const result = validateAuthResponse({\n        ...as,\n        authorization_response_iss_parameter_supported: false\n    }, client, parameters, expectedState);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!id_token) {\n        throw new OPE('\"parameters\" does not contain an ID Token');\n    }\n    const code = getURLSearchParameter(parameters, \"code\");\n    if (!code) {\n        throw new OPE('\"parameters\" does not contain an Authorization Code');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const requiredClaims = [\n        \"aud\",\n        \"exp\",\n        \"iat\",\n        \"iss\",\n        \"sub\",\n        \"nonce\",\n        \"c_hash\"\n    ];\n    if (typeof expectedState === \"string\") {\n        requiredClaims.push(\"s_hash\");\n    }\n    const { claims, header, key } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const clockSkew = getClockSkew(client);\n    const now = epochTime() + clockSkew;\n    if (claims.iat < now - 3600) {\n        throw new OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past');\n    }\n    if (typeof claims.c_hash !== \"string\" || await idTokenHashMatches(code, claims.c_hash, header.alg, key) !== true) {\n        throw new OPE('invalid ID Token \"c_hash\" (code hash) claim value');\n    }\n    if (claims.s_hash !== undefined && typeof expectedState !== \"string\") {\n        throw new OPE('could not verify ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (typeof expectedState === \"string\" && (typeof claims.s_hash !== \"string\" || await idTokenHashMatches(expectedState, claims.s_hash, header.alg, key) !== true)) {\n        throw new OPE('invalid ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (client.require_auth_time !== undefined && typeof claims.auth_time !== \"number\") {\n        throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    if (!validateString(expectedNonce)) {\n        throw new TypeError('\"expectedNonce\" must be a non-empty string');\n    }\n    if (claims.nonce !== expectedNonce) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n    }\n    if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n        throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n    }\n    return result;\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n    if (client !== undefined) {\n        if (header.alg !== client) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (header.alg !== \"RS256\") {\n        throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw new OPE(`\"${name}\" parameter must be provided only once`);\n    }\n    return value;\n}\nconst skipStateCheck = Symbol();\nconst expectNoState = Symbol();\nfunction validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    if (getURLSearchParameter(parameters, \"response\")) {\n        throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n    }\n    const iss = getURLSearchParameter(parameters, \"iss\");\n    const state = getURLSearchParameter(parameters, \"state\");\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw new OPE('response parameter \"iss\" (issuer) missing');\n    }\n    if (iss && iss !== as.issuer) {\n        throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n    }\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw new OPE('unexpected \"state\" response parameter encountered');\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new OPE('\"expectedState\" must be a non-empty string');\n            }\n            if (state === undefined) {\n                throw new OPE('response parameter \"state\" missing');\n            }\n            if (state !== expectedState) {\n                throw new OPE('unexpected \"state\" response parameter value');\n            }\n    }\n    const error = getURLSearchParameter(parameters, \"error\");\n    if (error) {\n        return {\n            error,\n            error_description: getURLSearchParameter(parameters, \"error_description\"),\n            error_uri: getURLSearchParameter(parameters, \"error_uri\")\n        };\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    const token = getURLSearchParameter(parameters, \"token\");\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n    switch(alg){\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n            return {\n                name: \"RSA-PSS\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"ES256\":\n        case \"ES384\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: `P-${alg.slice(-3)}`\n            };\n        case \"ES512\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-521\"\n            };\n        case \"EdDSA\":\n            {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        return crv;\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey(\"jwk\", key, algToSubtle(alg, jwk.crv), true, [\n        \"verify\"\n    ]);\n}\nasync function deviceAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"device_authorization_endpoint\", options);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.device_code)) {\n        throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.user_code)) {\n        throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.verification_uri)) {\n        throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (json.verification_uri_complete !== undefined && !validateString(json.verification_uri_complete)) {\n        throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n    }\n    if (json.interval !== undefined && (typeof json.interval !== \"number\" || json.interval <= 0)) {\n        throw new OPE('\"response\" body \"interval\" property must be a positive number');\n    }\n    return json;\n}\nasync function deviceCodeGrantRequest(as, client, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(deviceCode)) {\n        throw new TypeError('\"deviceCode\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"device_code\", deviceCode);\n    return tokenEndpointRequest(as, client, \"urn:ietf:params:oauth:grant-type:device_code\", parameters, options);\n}\nasync function processDeviceCodeResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nasync function generateKeyPair(alg, options) {\n    if (!validateString(alg)) {\n        throw new TypeError('\"alg\" must be a non-empty string');\n    }\n    const algorithm = algToSubtle(alg, alg === \"EdDSA\" ? options?.crv ?? \"Ed25519\" : undefined);\n    if (alg.startsWith(\"PS\") || alg.startsWith(\"RS\")) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ])\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\nfunction normalizeHtu(htu) {\n    const url = new URL(htu);\n    url.search = \"\";\n    url.hash = \"\";\n    return url.href;\n}\nasync function validateDPoP(as, request, accessTokenClaims, options) {\n    if (!request.headers.has(\"dpop\")) {\n        throw new OPE(\"operation indicated DPoP use but the request has no DPoP HTTP Header\");\n    }\n    if (request.headers.get(\"authorization\")?.toLowerCase().startsWith(\"dpop \") === false) {\n        throw new OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`);\n    }\n    if (typeof accessTokenClaims.cnf?.jkt !== \"string\") {\n        throw new OPE(\"operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim\");\n    }\n    const clockSkew = getClockSkew(options);\n    const proof = await validateJwt(request.headers.get(\"dpop\"), checkSigningAlgorithm.bind(undefined, undefined, as?.dpop_signing_alg_values_supported || SUPPORTED_JWS_ALGS), async ({ jwk, alg })=>{\n        if (!jwk) {\n            throw new OPE(\"DPoP Proof is missing the jwk header parameter\");\n        }\n        const key = await importJwk(alg, jwk);\n        if (key.type !== \"public\") {\n            throw new OPE(\"DPoP Proof jwk header parameter must contain a public key\");\n        }\n        return key;\n    }, clockSkew, getClockTolerance(options)).then(checkJwtType.bind(undefined, \"dpop+jwt\")).then(validatePresence.bind(undefined, [\n        \"iat\",\n        \"jti\",\n        \"ath\",\n        \"htm\",\n        \"htu\"\n    ]));\n    const now = epochTime() + clockSkew;\n    const diff = Math.abs(now - proof.claims.iat);\n    if (diff > 300) {\n        throw new OPE(\"DPoP Proof iat is not recent enough\");\n    }\n    if (proof.claims.htm !== request.method) {\n        throw new OPE(\"DPoP Proof htm mismatch\");\n    }\n    if (typeof proof.claims.htu !== \"string\" || normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n        throw new OPE(\"DPoP Proof htu mismatch\");\n    }\n    {\n        const accessToken = request.headers.get(\"authorization\").split(\" \")[1];\n        const expected = b64u(await crypto.subtle.digest(\"SHA-256\", encoder.encode(accessToken)));\n        if (proof.claims.ath !== expected) {\n            throw new OPE(\"DPoP Proof ath mismatch\");\n        }\n    }\n    {\n        let components;\n        switch(proof.header.jwk.kty){\n            case \"EC\":\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x,\n                    y: proof.header.jwk.y\n                };\n                break;\n            case \"OKP\":\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x\n                };\n                break;\n            case \"RSA\":\n                components = {\n                    e: proof.header.jwk.e,\n                    kty: proof.header.jwk.kty,\n                    n: proof.header.jwk.n\n                };\n                break;\n            default:\n                throw new UnsupportedOperationError();\n        }\n        const expected = b64u(await crypto.subtle.digest(\"SHA-256\", encoder.encode(JSON.stringify(components))));\n        if (accessTokenClaims.cnf.jkt !== expected) {\n            throw new OPE(\"JWT Access Token confirmation mismatch\");\n        }\n    }\n}\nasync function experimental_validateJwtAccessToken(as, request, expectedAudience, options) {\n    assertAs(as);\n    if (!looseInstanceOf(request, Request)) {\n        throw new TypeError('\"request\" must be an instance of Request');\n    }\n    if (!validateString(expectedAudience)) {\n        throw new OPE('\"expectedAudience\" must be a non-empty string');\n    }\n    const authorization = request.headers.get(\"authorization\");\n    if (!authorization) {\n        throw new OPE('\"request\" is missing an Authorization HTTP Header');\n    }\n    let { 0: scheme, 1: accessToken, length } = authorization.split(\" \");\n    scheme = scheme.toLowerCase();\n    switch(scheme){\n        case \"dpop\":\n        case \"bearer\":\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported Authorization HTTP Header scheme\");\n    }\n    if (length !== 2) {\n        throw new OPE(\"invalid Authorization HTTP Header format\");\n    }\n    const requiredClaims = [\n        \"iss\",\n        \"exp\",\n        \"aud\",\n        \"sub\",\n        \"iat\",\n        \"jti\",\n        \"client_id\"\n    ];\n    if (options?.requireDPoP || scheme === \"dpop\" || request.headers.has(\"dpop\")) {\n        requiredClaims.push(\"cnf\");\n    }\n    const { claims } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, undefined, SUPPORTED_JWS_ALGS), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(options), getClockTolerance(options)).then(checkJwtType.bind(undefined, \"at+jwt\")).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, expectedAudience));\n    for (const claim of [\n        \"client_id\",\n        \"jti\",\n        \"sub\"\n    ]){\n        if (typeof claims[claim] !== \"string\") {\n            throw new OPE(`unexpected JWT \"${claim}\" claim type`);\n        }\n    }\n    if (\"cnf\" in claims) {\n        if (!isJsonObject(claims.cnf)) {\n            throw new OPE('unexpected JWT \"cnf\" (confirmation) claim value');\n        }\n        const { 0: cnf, length } = Object.keys(claims.cnf);\n        if (length) {\n            if (length !== 1) {\n                throw new UnsupportedOperationError(\"multiple confirmation claims are not supported\");\n            }\n            if (cnf !== \"jkt\") {\n                throw new UnsupportedOperationError(\"unsupported JWT Confirmation method\");\n            }\n        }\n    }\n    if (options?.requireDPoP || scheme === \"dpop\" || claims.cnf?.jkt !== undefined || request.headers.has(\"dpop\")) {\n        await validateDPoP(as, request, claims, options);\n    }\n    return claims;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vYXV0aDR3ZWJhcGkvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUE7QUFDSixJQUFJLE9BQU9DLGNBQWMsZUFBZSxDQUFDQSxVQUFVQyxTQUFTLEVBQUVDLGFBQWEsaUJBQWlCO0lBQ3hGLE1BQU1DLE9BQU87SUFDYixNQUFNQyxVQUFVO0lBQ2hCTCxhQUFhLENBQUMsRUFBRUksS0FBSyxDQUFDLEVBQUVDLFFBQVEsQ0FBQztBQUNyQztBQUNBLFNBQVNDLGdCQUFnQkMsS0FBSyxFQUFFQyxRQUFRO0lBQ3BDLElBQUlELFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxPQUFRQSxpQkFBaUJDLFlBQ3JCQyxPQUFPQyxjQUFjLENBQUNILE1BQU0sQ0FBQ0ksT0FBT0MsV0FBVyxDQUFDLEtBQUtKLFNBQVNLLFNBQVMsQ0FBQ0YsT0FBT0MsV0FBVyxDQUFDO0lBQ25HLEVBQ0EsT0FBTTtRQUNGLE9BQU87SUFDWDtBQUNKO0FBQ08sTUFBTUUsWUFBWUgsU0FBUztBQUMzQixNQUFNSSxpQkFBaUJKLFNBQVM7QUFDaEMsTUFBTUssMkJBQTJCTCxTQUFTO0FBQzFDLE1BQU1NLDBCQUEwQkQseUJBQXlCO0FBQ3pELE1BQU1FLDRCQUE0QlAsU0FBUztBQUMzQyxNQUFNUSwyQkFBMkJELDBCQUEwQjtBQUNsRSxNQUFNRSxVQUFVLElBQUlDO0FBQ3BCLE1BQU1DLFVBQVUsSUFBSUM7QUFDcEIsU0FBU0MsSUFBSWpCLEtBQUs7SUFDZCxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUMzQixPQUFPYSxRQUFRSyxNQUFNLENBQUNsQjtJQUMxQjtJQUNBLE9BQU9lLFFBQVFJLE1BQU0sQ0FBQ25CO0FBQzFCO0FBQ0EsTUFBTW9CLGFBQWE7QUFDbkIsU0FBU0MsZ0JBQWdCckIsS0FBSztJQUMxQixJ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MFAsUUFBUSxPQUFPO2dCQUNmLE1BQU0sSUFBSTFQLDBCQUEwQjtZQUN4QztRQUNKO0lBQ0o7SUFDQSxJQUFJTSxTQUFTNlUsZUFDVDlLLFdBQVcsVUFDWHZDLE9BQU80SCxHQUFHLEVBQUVnRixRQUFRaFYsYUFDcEI4VSxRQUFReFQsT0FBTyxDQUFDckIsR0FBRyxDQUFDLFNBQVM7UUFDN0IsTUFBTTRVLGFBQWE3TyxJQUFJOE8sU0FBUzFNLFFBQVF4SDtJQUM1QztJQUNBLE9BQU93SDtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29hdXRoNHdlYmFwaS9idWlsZC9pbmRleC5qcz8zZDQxIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBVU0VSX0FHRU5UO1xuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IudXNlckFnZW50Py5zdGFydHNXaXRoPy4oJ01vemlsbGEvNS4wICcpKSB7XG4gICAgY29uc3QgTkFNRSA9ICdvYXV0aDR3ZWJhcGknO1xuICAgIGNvbnN0IFZFUlNJT04gPSAndjIuOC4xJztcbiAgICBVU0VSX0FHRU5UID0gYCR7TkFNRX0vJHtWRVJTSU9OfWA7XG59XG5mdW5jdGlvbiBsb29zZUluc3RhbmNlT2YoaW5wdXQsIGV4cGVjdGVkKSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGlucHV0IGluc3RhbmNlb2YgZXhwZWN0ZWQgfHxcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dClbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gZXhwZWN0ZWQucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgY2xvY2tTa2V3ID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgY2xvY2tUb2xlcmFuY2UgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBleHBlcmltZW50YWxfY3VzdG9tRmV0Y2ggPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBleHBlcmltZW50YWxDdXN0b21GZXRjaCA9IGV4cGVyaW1lbnRhbF9jdXN0b21GZXRjaDtcbmV4cG9ydCBjb25zdCBleHBlcmltZW50YWxfdXNlTXRsc0FsaWFzID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgZXhwZXJpbWVudGFsVXNlTXRsc0FsaWFzID0gZXhwZXJpbWVudGFsX3VzZU10bHNBbGlhcztcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmZ1bmN0aW9uIGJ1ZihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVyLmVuY29kZShpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShpbnB1dCk7XG59XG5jb25zdCBDSFVOS19TSVpFID0gMHg4MDAwO1xuZnVuY3Rpb24gZW5jb2RlQmFzZTY0VXJsKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgaW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfVxuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQuYnl0ZUxlbmd0aDsgaSArPSBDSFVOS19TSVpFKSB7XG4gICAgICAgIGFyci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaW5wdXQuc3ViYXJyYXkoaSwgaSArIENIVU5LX1NJWkUpKSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKGFyci5qb2luKCcnKSkucmVwbGFjZSgvPS9nLCAnJykucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG5mdW5jdGlvbiBkZWNvZGVCYXNlNjRVcmwoaW5wdXQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBiaW5hcnkgPSBhdG9iKGlucHV0LnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJykucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlc1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1RoZSBpbnB1dCB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC4nLCB7IGNhdXNlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGI2NHUoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVjb2RlQmFzZTY0VXJsKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NFVybChpbnB1dCk7XG59XG5jbGFzcyBMUlUge1xuICAgIGNvbnN0cnVjdG9yKG1heFNpemUpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemU7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh2ID0gdGhpcy5fY2FjaGUuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShrZXksIHYpO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KSB8fCB0aGlzLl9jYWNoZS5oYXMoa2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLnNpemUgPj0gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlID8/ICdvcGVyYXRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4odGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9wZXJhdGlvblByb2Nlc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4odGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxufVxuY29uc3QgT1BFID0gT3BlcmF0aW9uUHJvY2Vzc2luZ0Vycm9yO1xuY29uc3QgZHBvcE5vbmNlcyA9IG5ldyBMUlUoMTAwKTtcbmZ1bmN0aW9uIGlzQ3J5cHRvS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkgaW5zdGFuY2VvZiBDcnlwdG9LZXk7XG59XG5mdW5jdGlvbiBpc1ByaXZhdGVLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGlzQ3J5cHRvS2V5KGtleSkgJiYga2V5LnR5cGUgPT09ICdwcml2YXRlJztcbn1cbmZ1bmN0aW9uIGlzUHVibGljS2V5KGtleSkge1xuICAgIHJldHVybiBpc0NyeXB0b0tleShrZXkpICYmIGtleS50eXBlID09PSAncHVibGljJztcbn1cbmNvbnN0IFNVUFBPUlRFRF9KV1NfQUxHUyA9IFtcbiAgICAnUFMyNTYnLFxuICAgICdFUzI1NicsXG4gICAgJ1JTMjU2JyxcbiAgICAnUFMzODQnLFxuICAgICdFUzM4NCcsXG4gICAgJ1JTMzg0JyxcbiAgICAnUFM1MTInLFxuICAgICdFUzUxMicsXG4gICAgJ1JTNTEyJyxcbiAgICAnRWREU0EnLFxuXTtcbmZ1bmN0aW9uIHByb2Nlc3NEcG9wTm9uY2UocmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5oYXMoJ2Rwb3Atbm9uY2UnKSkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXNwb25zZS51cmwpO1xuICAgICAgICAgICAgZHBvcE5vbmNlcy5zZXQodXJsLm9yaWdpbiwgcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2Rwb3Atbm9uY2UnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVUeXAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eYXBwbGljYXRpb25cXC8vLCAnJyk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcHJlcGFyZUhlYWRlcnMoaW5wdXQpIHtcbiAgICBpZiAobG9vc2VJbnN0YW5jZU9mKGlucHV0LCBIZWFkZXJzKSkge1xuICAgICAgICBpbnB1dCA9IE9iamVjdC5mcm9tRW50cmllcyhpbnB1dC5lbnRyaWVzKCkpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQpO1xuICAgIGlmIChVU0VSX0FHRU5UICYmICFoZWFkZXJzLmhhcygndXNlci1hZ2VudCcpKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCd1c2VyLWFnZW50JywgVVNFUl9BR0VOVCk7XG4gICAgfVxuICAgIGlmIChoZWFkZXJzLmhhcygnYXV0aG9yaXphdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5oZWFkZXJzXCIgbXVzdCBub3QgaW5jbHVkZSB0aGUgXCJhdXRob3JpemF0aW9uXCIgaGVhZGVyIG5hbWUnKTtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnMuaGFzKCdkcG9wJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmhlYWRlcnNcIiBtdXN0IG5vdCBpbmNsdWRlIHRoZSBcImRwb3BcIiBoZWFkZXIgbmFtZScpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIHNpZ25hbCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuc2lnbmFsXCIgbXVzdCByZXR1cm4gb3IgYmUgYW4gaW5zdGFuY2Ugb2YgQWJvcnRTaWduYWwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyeVJlcXVlc3QoaXNzdWVySWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgIGlmICghKGlzc3VlcklkZW50aWZpZXIgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiaXNzdWVySWRlbnRpZmllclwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJyk7XG4gICAgfVxuICAgIGlmIChpc3N1ZXJJZGVudGlmaWVyLnByb3RvY29sICE9PSAnaHR0cHM6JyAmJiBpc3N1ZXJJZGVudGlmaWVyLnByb3RvY29sICE9PSAnaHR0cDonKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiaXNzdWVyLnByb3RvY29sXCIgbXVzdCBiZSBcImh0dHBzOlwiIG9yIFwiaHR0cDpcIicpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGlzc3VlcklkZW50aWZpZXIuaHJlZik7XG4gICAgc3dpdGNoIChvcHRpb25zPy5hbGdvcml0aG0pIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ29pZGMnOlxuICAgICAgICAgICAgdXJsLnBhdGhuYW1lID0gYCR7dXJsLnBhdGhuYW1lfS8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbmAucmVwbGFjZSgnLy8nLCAnLycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29hdXRoMic6XG4gICAgICAgICAgICBpZiAodXJsLnBhdGhuYW1lID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICB1cmwucGF0aG5hbWUgPSBgLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXJgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJsLnBhdGhuYW1lID0gYC53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyLyR7dXJsLnBhdGhuYW1lfWAucmVwbGFjZSgnLy8nLCAnLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuYWxnb3JpdGhtXCIgbXVzdCBiZSBcIm9pZGNcIiAoZGVmYXVsdCksIG9yIFwib2F1dGgyXCInKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHJldHVybiAob3B0aW9ucz8uW2V4cGVyaW1lbnRhbF9jdXN0b21GZXRjaF0gfHwgZmV0Y2gpKHVybC5ocmVmLCB7XG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgPyBzaWduYWwob3B0aW9ucy5zaWduYWwpIDogbnVsbCxcbiAgICB9KS50aGVuKHByb2Nlc3NEcG9wTm9uY2UpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiBpbnB1dC5sZW5ndGggIT09IDA7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0Rpc2NvdmVyeVJlc3BvbnNlKGV4cGVjdGVkSXNzdWVySWRlbnRpZmllciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoIShleHBlY3RlZElzc3VlcklkZW50aWZpZXIgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXhwZWN0ZWRJc3N1ZXJcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcpO1xuICAgIH1cbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBBdXRob3JpemF0aW9uIFNlcnZlciBNZXRhZGF0YSByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24uaXNzdWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlzc3VlclwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChuZXcgVVJMKGpzb24uaXNzdWVyKS5ocmVmICE9PSBleHBlY3RlZElzc3VlcklkZW50aWZpZXIuaHJlZikge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlzc3VlclwiIGRvZXMgbm90IG1hdGNoIFwiZXhwZWN0ZWRJc3N1ZXJcIicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKCkge1xuICAgIHJldHVybiBiNjR1KGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21Db2RlVmVyaWZpZXIoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TdGF0ZSgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbU5vbmNlKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZVBLQ0VDb2RlQ2hhbGxlbmdlKGNvZGVWZXJpZmllcikge1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoY29kZVZlcmlmaWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNvZGVWZXJpZmllclwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGNvZGVWZXJpZmllcikpKTtcbn1cbmZ1bmN0aW9uIGdldEtleUFuZEtpZChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENyeXB0b0tleSkge1xuICAgICAgICByZXR1cm4geyBrZXk6IGlucHV0IH07XG4gICAgfVxuICAgIGlmICghKGlucHV0Py5rZXkgaW5zdGFuY2VvZiBDcnlwdG9LZXkpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmtpZCAhPT0gdW5kZWZpbmVkICYmICF2YWxpZGF0ZVN0cmluZyhpbnB1dC5raWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wia2lkXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsga2V5OiBpbnB1dC5rZXksIGtpZDogaW5wdXQua2lkIH07XG59XG5mdW5jdGlvbiBmb3JtVXJsRW5jb2RlKHRva2VuKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0b2tlbikucmVwbGFjZSgvJTIwL2csICcrJyk7XG59XG5mdW5jdGlvbiBjbGllbnRTZWNyZXRCYXNpYyhjbGllbnRJZCwgY2xpZW50U2VjcmV0KSB7XG4gICAgY29uc3QgdXNlcm5hbWUgPSBmb3JtVXJsRW5jb2RlKGNsaWVudElkKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IGZvcm1VcmxFbmNvZGUoY2xpZW50U2VjcmV0KTtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGJ0b2EoYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCk7XG4gICAgcmV0dXJuIGBCYXNpYyAke2NyZWRlbnRpYWxzfWA7XG59XG5mdW5jdGlvbiBwc0FsZyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0uaGFzaC5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdQUzI1Nic7XG4gICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdQUzM4NCc7XG4gICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgcmV0dXJuICdQUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgUnNhSGFzaGVkS2V5QWxnb3JpdGhtIGhhc2ggbmFtZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJzQWxnKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnU0hBLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ1JTMjU2JztcbiAgICAgICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ1JTMzg0JztcbiAgICAgICAgY2FzZSAnU0hBLTUxMic6XG4gICAgICAgICAgICByZXR1cm4gJ1JTNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBSc2FIYXNoZWRLZXlBbGdvcml0aG0gaGFzaCBuYW1lJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNBbGcoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpIHtcbiAgICAgICAgY2FzZSAnUC0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdFUzI1Nic7XG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnRVMzODQnO1xuICAgICAgICBjYXNlICdQLTUyMSc6XG4gICAgICAgICAgICByZXR1cm4gJ0VTNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBFY0tleUFsZ29yaXRobSBuYW1lZEN1cnZlJyk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5VG9Kd3Moa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnUlNBLVBTUyc6XG4gICAgICAgICAgICByZXR1cm4gcHNBbGcoa2V5KTtcbiAgICAgICAgY2FzZSAnUlNBU1NBLVBLQ1MxLXYxXzUnOlxuICAgICAgICAgICAgcmV0dXJuIHJzQWxnKGtleSk7XG4gICAgICAgIGNhc2UgJ0VDRFNBJzpcbiAgICAgICAgICAgIHJldHVybiBlc0FsZyhrZXkpO1xuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgICAgICAgcmV0dXJuICdFZERTQSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgQ3J5cHRvS2V5IGFsZ29yaXRobSBuYW1lJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2xvY2tTa2V3KGNsaWVudCkge1xuICAgIGlmIChjbGllbnQgJiYgY2xvY2tTa2V3IGluIGNsaWVudCkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGNsaWVudFtjbG9ja1NrZXddKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudFtjbG9ja1NrZXddO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KSB7XG4gICAgaWYgKGNsaWVudCAmJiBjbG9ja1RvbGVyYW5jZSBpbiBjbGllbnQpIHtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gY2xpZW50W2Nsb2NrVG9sZXJhbmNlXTtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0b2xlcmFuY2UpICYmIE1hdGguc2lnbih0b2xlcmFuY2UpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvbGVyYW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMzA7XG59XG5mdW5jdGlvbiBlcG9jaFRpbWUoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufVxuZnVuY3Rpb24gY2xpZW50QXNzZXJ0aW9uKGFzLCBjbGllbnQpIHtcbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgYXVkOiBbYXMuaXNzdWVyLCBhcy50b2tlbl9lbmRwb2ludF0sXG4gICAgICAgIGV4cDogbm93ICsgNjAsXG4gICAgICAgIGlhdDogbm93LFxuICAgICAgICBuYmY6IG5vdyxcbiAgICAgICAgaXNzOiBjbGllbnQuY2xpZW50X2lkLFxuICAgICAgICBzdWI6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByaXZhdGVLZXlKd3QoYXMsIGNsaWVudCwga2V5LCBraWQpIHtcbiAgICByZXR1cm4gand0KHtcbiAgICAgICAgYWxnOiBrZXlUb0p3cyhrZXkpLFxuICAgICAgICBraWQsXG4gICAgfSwgY2xpZW50QXNzZXJ0aW9uKGFzLCBjbGllbnQpLCBrZXkpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QXMoYXMpIHtcbiAgICBpZiAodHlwZW9mIGFzICE9PSAnb2JqZWN0JyB8fCBhcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzXCIgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhhcy5pc3N1ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMuaXNzdWVyXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGllbnQoY2xpZW50KSB7XG4gICAgaWYgKHR5cGVvZiBjbGllbnQgIT09ICdvYmplY3QnIHx8IGNsaWVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNsaWVudFwiIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoY2xpZW50LmNsaWVudF9pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjbGllbnQuY2xpZW50X2lkXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGllbnRTZWNyZXQoY2xpZW50U2VjcmV0KSB7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhjbGllbnRTZWNyZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2xpZW50LmNsaWVudF9zZWNyZXRcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gY2xpZW50U2VjcmV0O1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm9DbGllbnRQcml2YXRlS2V5KGNsaWVudEF1dGhNZXRob2QsIGNsaWVudFByaXZhdGVLZXkpIHtcbiAgICBpZiAoY2xpZW50UHJpdmF0ZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwib3B0aW9ucy5jbGllbnRQcml2YXRlS2V5XCIgcHJvcGVydHkgbXVzdCBub3QgYmUgcHJvdmlkZWQgd2hlbiAke2NsaWVudEF1dGhNZXRob2R9IGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2QgaXMgdXNlZC5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnROb0NsaWVudFNlY3JldChjbGllbnRBdXRoTWV0aG9kLCBjbGllbnRTZWNyZXQpIHtcbiAgICBpZiAoY2xpZW50U2VjcmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJjbGllbnQuY2xpZW50X3NlY3JldFwiIHByb3BlcnR5IG11c3Qgbm90IGJlIHByb3ZpZGVkIHdoZW4gJHtjbGllbnRBdXRoTWV0aG9kfSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIGlzIHVzZWQuYCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY2xpZW50QXV0aGVudGljYXRpb24oYXMsIGNsaWVudCwgYm9keSwgaGVhZGVycywgY2xpZW50UHJpdmF0ZUtleSkge1xuICAgIGJvZHkuZGVsZXRlKCdjbGllbnRfc2VjcmV0Jyk7XG4gICAgYm9keS5kZWxldGUoJ2NsaWVudF9hc3NlcnRpb25fdHlwZScpO1xuICAgIGJvZHkuZGVsZXRlKCdjbGllbnRfYXNzZXJ0aW9uJyk7XG4gICAgc3dpdGNoIChjbGllbnQudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfYmFzaWMnOiB7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFByaXZhdGVLZXkoJ2NsaWVudF9zZWNyZXRfYmFzaWMnLCBjbGllbnRQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdhdXRob3JpemF0aW9uJywgY2xpZW50U2VjcmV0QmFzaWMoY2xpZW50LmNsaWVudF9pZCwgYXNzZXJ0Q2xpZW50U2VjcmV0KGNsaWVudC5jbGllbnRfc2VjcmV0KSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY2xpZW50X3NlY3JldF9wb3N0Jzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRQcml2YXRlS2V5KCdjbGllbnRfc2VjcmV0X3Bvc3QnLCBjbGllbnRQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfc2VjcmV0JywgYXNzZXJ0Q2xpZW50U2VjcmV0KGNsaWVudC5jbGllbnRfc2VjcmV0KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwcml2YXRlX2tleV9qd3QnOiB7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFNlY3JldCgncHJpdmF0ZV9rZXlfand0JywgY2xpZW50LmNsaWVudF9zZWNyZXQpO1xuICAgICAgICAgICAgaWYgKGNsaWVudFByaXZhdGVLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5jbGllbnRQcml2YXRlS2V5XCIgbXVzdCBiZSBwcm92aWRlZCB3aGVuIFwiY2xpZW50LnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kXCIgaXMgXCJwcml2YXRlX2tleV9qd3RcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBrZXksIGtpZCB9ID0gZ2V0S2V5QW5kS2lkKGNsaWVudFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgaWYgKCFpc1ByaXZhdGVLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5jbGllbnRQcml2YXRlS2V5LmtleVwiIG11c3QgYmUgYSBwcml2YXRlIENyeXB0b0tleScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9hc3NlcnRpb25fdHlwZScsICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Y2xpZW50LWFzc2VydGlvbi10eXBlOmp3dC1iZWFyZXInKTtcbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfYXNzZXJ0aW9uJywgYXdhaXQgcHJpdmF0ZUtleUp3dChhcywgY2xpZW50LCBrZXksIGtpZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGxzX2NsaWVudF9hdXRoJzpcbiAgICAgICAgY2FzZSAnc2VsZl9zaWduZWRfdGxzX2NsaWVudF9hdXRoJzpcbiAgICAgICAgY2FzZSAnbm9uZSc6IHtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50U2VjcmV0KGNsaWVudC50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCwgY2xpZW50LmNsaWVudF9zZWNyZXQpO1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRQcml2YXRlS2V5KGNsaWVudC50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCwgY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIGNsaWVudCB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCcpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGp3dChoZWFkZXIsIGNsYWltc1NldCwga2V5KSB7XG4gICAgaWYgKCFrZXkudXNhZ2VzLmluY2x1ZGVzKCdzaWduJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ3J5cHRvS2V5IGluc3RhbmNlcyB1c2VkIGZvciBzaWduaW5nIGFzc2VydGlvbnMgbXVzdCBpbmNsdWRlIFwic2lnblwiIGluIHRoZWlyIFwidXNhZ2VzXCInKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXQgPSBgJHtiNjR1KGJ1ZihKU09OLnN0cmluZ2lmeShoZWFkZXIpKSl9LiR7YjY0dShidWYoSlNPTi5zdHJpbmdpZnkoY2xhaW1zU2V0KSkpfWA7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYjY0dShhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oa2V5VG9TdWJ0bGUoa2V5KSwga2V5LCBidWYoaW5wdXQpKSk7XG4gICAgcmV0dXJuIGAke2lucHV0fS4ke3NpZ25hdHVyZX1gO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzc3VlUmVxdWVzdE9iamVjdChhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBwcml2YXRlS2V5KSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IHsga2V5LCBraWQgfSA9IGdldEtleUFuZEtpZChwcml2YXRlS2V5KTtcbiAgICBpZiAoIWlzUHJpdmF0ZUtleShrZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicHJpdmF0ZUtleS5rZXlcIiBtdXN0IGJlIGEgcHJpdmF0ZSBDcnlwdG9LZXknKTtcbiAgICB9XG4gICAgcGFyYW1ldGVycy5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgY29uc3QgY2xhaW1zID0ge1xuICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMocGFyYW1ldGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBqdGk6IHJhbmRvbUJ5dGVzKCksXG4gICAgICAgIGF1ZDogYXMuaXNzdWVyLFxuICAgICAgICBleHA6IG5vdyArIDYwLFxuICAgICAgICBpYXQ6IG5vdyxcbiAgICAgICAgbmJmOiBub3csXG4gICAgICAgIGlzczogY2xpZW50LmNsaWVudF9pZCxcbiAgICB9O1xuICAgIGxldCByZXNvdXJjZTtcbiAgICBpZiAocGFyYW1ldGVycy5oYXMoJ3Jlc291cmNlJykgJiZcbiAgICAgICAgKHJlc291cmNlID0gcGFyYW1ldGVycy5nZXRBbGwoJ3Jlc291cmNlJykpICYmXG4gICAgICAgIHJlc291cmNlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2xhaW1zLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXJzLmhhcygnY2xhaW1zJykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbWV0ZXJzLmdldCgnY2xhaW1zJyk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wiY2xhaW1zXCIgcGFyYW1ldGVyIG11c3QgYmUgcGFzc2VkIGFzIGEgVVRGLTggZW5jb2RlZCBKU09OJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNsYWltcy5jbGFpbXMgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSB0aGUgXCJjbGFpbXNcIiBwYXJhbWV0ZXIgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3QoY2xhaW1zLmNsYWltcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wiY2xhaW1zXCIgcGFyYW1ldGVyIG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGp3dCh7XG4gICAgICAgIGFsZzoga2V5VG9Kd3Moa2V5KSxcbiAgICAgICAgdHlwOiAnb2F1dGgtYXV0aHotcmVxK2p3dCcsXG4gICAgICAgIGtpZCxcbiAgICB9LCBjbGFpbXMsIGtleSk7XG59XG5hc3luYyBmdW5jdGlvbiBkcG9wUHJvb2ZKd3QoaGVhZGVycywgb3B0aW9ucywgdXJsLCBodG0sIGNsb2NrU2tldywgYWNjZXNzVG9rZW4pIHtcbiAgICBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSwgbm9uY2UgPSBkcG9wTm9uY2VzLmdldCh1cmwub3JpZ2luKSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWlzUHJpdmF0ZUtleShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1AucHJpdmF0ZUtleVwiIG11c3QgYmUgYSBwcml2YXRlIENyeXB0b0tleScpO1xuICAgIH1cbiAgICBpZiAoIWlzUHVibGljS2V5KHB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJEUG9QLnB1YmxpY0tleVwiIG11c3QgYmUgYSBwdWJsaWMgQ3J5cHRvS2V5Jyk7XG4gICAgfVxuICAgIGlmIChub25jZSAhPT0gdW5kZWZpbmVkICYmICF2YWxpZGF0ZVN0cmluZyhub25jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJEUG9QLm5vbmNlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcHVibGljS2V5LmV4dHJhY3RhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5wdWJsaWNLZXkuZXh0cmFjdGFibGVcIiBtdXN0IGJlIHRydWUnKTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBjbG9ja1NrZXc7XG4gICAgY29uc3QgcHJvb2YgPSBhd2FpdCBqd3Qoe1xuICAgICAgICBhbGc6IGtleVRvSndzKHByaXZhdGVLZXkpLFxuICAgICAgICB0eXA6ICdkcG9wK2p3dCcsXG4gICAgICAgIGp3azogYXdhaXQgcHVibGljSndrKHB1YmxpY0tleSksXG4gICAgfSwge1xuICAgICAgICBpYXQ6IG5vdyxcbiAgICAgICAganRpOiByYW5kb21CeXRlcygpLFxuICAgICAgICBodG0sXG4gICAgICAgIG5vbmNlLFxuICAgICAgICBodHU6IGAke3VybC5vcmlnaW59JHt1cmwucGF0aG5hbWV9YCxcbiAgICAgICAgYXRoOiBhY2Nlc3NUb2tlbiA/IGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBidWYoYWNjZXNzVG9rZW4pKSkgOiB1bmRlZmluZWQsXG4gICAgfSwgcHJpdmF0ZUtleSk7XG4gICAgaGVhZGVycy5zZXQoJ2Rwb3AnLCBwcm9vZik7XG59XG5sZXQgandrQ2FjaGU7XG5hc3luYyBmdW5jdGlvbiBwdWJsaWNKd2soa2V5KSB7XG4gICAgandrQ2FjaGUgfHwgKGp3a0NhY2hlID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgaWYgKGp3a0NhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBqd2tDYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgY29uc3QgeyBrdHksIGUsIG4sIHgsIHksIGNydiB9ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ2p3aycsIGtleSk7XG4gICAgY29uc3QgandrID0geyBrdHksIGUsIG4sIHgsIHksIGNydiB9O1xuICAgIGp3a0NhY2hlLnNldChrZXksIGp3ayk7XG4gICAgcmV0dXJuIGp3aztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRW5kcG9pbnQodmFsdWUsIGVuZHBvaW50LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKG9wdGlvbnM/LltleHBlcmltZW50YWxfdXNlTXRsc0FsaWFzXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJhcy5tdGxzX2VuZHBvaW50X2FsaWFzZXMuJHtlbmRwb2ludH1cIiBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcImFzLiR7ZW5kcG9pbnR9XCIgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVVJMKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmRwb2ludChhcywgZW5kcG9pbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8uW2V4cGVyaW1lbnRhbF91c2VNdGxzQWxpYXNdICYmXG4gICAgICAgIGFzLm10bHNfZW5kcG9pbnRfYWxpYXNlcyAmJlxuICAgICAgICBlbmRwb2ludCBpbiBhcy5tdGxzX2VuZHBvaW50X2FsaWFzZXMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRW5kcG9pbnQoYXMubXRsc19lbmRwb2ludF9hbGlhc2VzW2VuZHBvaW50XSwgZW5kcG9pbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVFbmRwb2ludChhc1tlbmRwb2ludF0sIGVuZHBvaW50KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdChhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ3B1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMuRFBvUCwgdXJsLCAnUE9TVCcsIGdldENsb2NrU2tldyhjbGllbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09BdXRoMkVycm9yKGlucHV0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBpbnB1dDtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5lcnJvciAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMiAmJiB2YWx1ZVswXSA9PT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBTUExJVF9SRUdFWFAgPSAvKCg/Oix8LCApP1swLTlhLXpBLVohIyQlJicqKy0uXl9gfH5dKz0pLztcbmNvbnN0IFNDSEVNRVNfUkVHRVhQID0gLyg/Ol58LCA/KShbMC05YS16QS1aISMkJSYnKitcXC0uXl9gfH5dKykoPz0kfFsgLF0pL2c7XG5mdW5jdGlvbiB3d3dBdXRoKHNjaGVtZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgYXJyID0gcGFyYW1zLnNwbGl0KFNQTElUX1JFR0VYUCkuc2xpY2UoMSk7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtZTogc2NoZW1lLnRvTG93ZXJDYXNlKCksIHBhcmFtZXRlcnM6IHt9IH07XG4gICAgfVxuICAgIGFyclthcnIubGVuZ3RoIC0gMV0gPSBhcnJbYXJyLmxlbmd0aCAtIDFdLnJlcGxhY2UoLywkLywgJycpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBpZHggPSBpO1xuICAgICAgICBpZiAoYXJyW2lkeF1bMF0gPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChhcnJbaWR4XS5zbGljZSgtMSkgIT09ICdcIicgJiYgKytpIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFycltpZHhdICs9IGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBhcnJbaWR4IC0gMV0ucmVwbGFjZSgvXig/OiwgPyl8PSQvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBhcmFtZXRlcnNba2V5XSA9IHVucXVvdGUoYXJyW2lkeF0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHNjaGVtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwYXJhbWV0ZXJzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VXd3dBdXRoZW50aWNhdGVDaGFsbGVuZ2VzKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmhlYWRlcnMuaGFzKCd3d3ctYXV0aGVudGljYXRlJykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3d3dy1hdXRoZW50aWNhdGUnKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgMTogc2NoZW1lLCBpbmRleCB9IG9mIGhlYWRlci5tYXRjaEFsbChTQ0hFTUVTX1JFR0VYUCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW3NjaGVtZSwgaW5kZXhdKTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNoYWxsZW5nZXMgPSByZXN1bHQubWFwKChbc2NoZW1lLCBpbmRleE9mXSwgaSwgb3RoZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBvdGhlcnNbaSArIDFdO1xuICAgICAgICBsZXQgcGFyYW1ldGVycztcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBoZWFkZXIuc2xpY2UoaW5kZXhPZiwgbmV4dFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0gaGVhZGVyLnNsaWNlKGluZGV4T2YpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3d3dBdXRoKHNjaGVtZSwgcGFyYW1ldGVycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYWxsZW5nZXM7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1B1c2hlZEF1dGhvcml6YXRpb25SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMSkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gUHVzaGVkIEF1dGhvcml6YXRpb24gUmVxdWVzdCBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24ucmVxdWVzdF91cmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwicmVxdWVzdF91cmlcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24uZXhwaXJlc19pbiAhPT0gJ251bWJlcicgfHwganNvbi5leHBpcmVzX2luIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJleHBpcmVzX2luXCIgcHJvcGVydHkgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QoYWNjZXNzVG9rZW4sIG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBib2R5LCBvcHRpb25zKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhhY2Nlc3NUb2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhY2Nlc3NUb2tlblwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghKHVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ1cmxcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcpO1xuICAgIH1cbiAgICBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMoaGVhZGVycyk7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF3YWl0IGRwb3BQcm9vZkp3dChoZWFkZXJzLCBvcHRpb25zLkRQb1AsIHVybCwgJ0dFVCcsIGdldENsb2NrU2tldyh7IFtjbG9ja1NrZXddOiBvcHRpb25zPy5bY2xvY2tTa2V3XSB9KSwgYWNjZXNzVG9rZW4pO1xuICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGBEUG9QICR7YWNjZXNzVG9rZW59YCk7XG4gICAgfVxuICAgIHJldHVybiAob3B0aW9ucz8uW2V4cGVyaW1lbnRhbF9jdXN0b21GZXRjaF0gfHwgZmV0Y2gpKHVybC5ocmVmLCB7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCA/IHNpZ25hbChvcHRpb25zLnNpZ25hbCkgOiBudWxsLFxuICAgIH0pLnRoZW4ocHJvY2Vzc0Rwb3BOb25jZSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXNlckluZm9SZXF1ZXN0KGFzLCBjbGllbnQsIGFjY2Vzc1Rva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ3VzZXJpbmZvX2VuZHBvaW50Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3dCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKCdhY2NlcHQnLCAnYXBwbGljYXRpb24vand0Jyk7XG4gICAgfVxuICAgIHJldHVybiBwcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QoYWNjZXNzVG9rZW4sICdHRVQnLCB1cmwsIGhlYWRlcnMsIG51bGwsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgW2Nsb2NrU2tld106IGdldENsb2NrU2tldyhjbGllbnQpLFxuICAgIH0pO1xufVxubGV0IGp3a3NDYWNoZTtcbmFzeW5jIGZ1bmN0aW9uIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpIHtcbiAgICBjb25zdCB7IGFsZywga2lkIH0gPSBoZWFkZXI7XG4gICAgY2hlY2tTdXBwb3J0ZWRKd3NBbGcoYWxnKTtcbiAgICBsZXQgandrcztcbiAgICBsZXQgYWdlO1xuICAgIGp3a3NDYWNoZSB8fCAoandrc0NhY2hlID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgaWYgKGp3a3NDYWNoZS5oYXMoYXMpKSB7XG4gICAgICAgIDtcbiAgICAgICAgKHsgandrcywgYWdlIH0gPSBqd2tzQ2FjaGUuZ2V0KGFzKSk7XG4gICAgICAgIGlmIChhZ2UgPj0gMzAwKSB7XG4gICAgICAgICAgICBqd2tzQ2FjaGUuZGVsZXRlKGFzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgandrcyA9IGF3YWl0IGp3a3NSZXF1ZXN0KGFzLCBvcHRpb25zKS50aGVuKHByb2Nlc3NKd2tzUmVzcG9uc2UpO1xuICAgICAgICBhZ2UgPSAwO1xuICAgICAgICBqd2tzQ2FjaGUuc2V0KGFzLCB7XG4gICAgICAgICAgICBqd2tzLFxuICAgICAgICAgICAgaWF0OiBlcG9jaFRpbWUoKSxcbiAgICAgICAgICAgIGdldCBhZ2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVwb2NoVGltZSgpIC0gdGhpcy5pYXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGt0eTtcbiAgICBzd2l0Y2ggKGFsZy5zbGljZSgwLCAyKSkge1xuICAgICAgICBjYXNlICdSUyc6XG4gICAgICAgIGNhc2UgJ1BTJzpcbiAgICAgICAgICAgIGt0eSA9ICdSU0EnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VTJzpcbiAgICAgICAgICAgIGt0eSA9ICdFQyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRWQnOlxuICAgICAgICAgICAga3R5ID0gJ09LUCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBqd2tzLmtleXMuZmlsdGVyKChqd2spID0+IHtcbiAgICAgICAgaWYgKGp3ay5rdHkgIT09IGt0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChraWQgIT09IHVuZGVmaW5lZCAmJiBraWQgIT09IGp3ay5raWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLmFsZyAhPT0gdW5kZWZpbmVkICYmIGFsZyAhPT0gandrLmFsZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqd2sudXNlICE9PSB1bmRlZmluZWQgJiYgandrLnVzZSAhPT0gJ3NpZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLmtleV9vcHM/LmluY2x1ZGVzKCd2ZXJpZnknKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRVMyNTYnICYmIGp3ay5jcnYgIT09ICdQLTI1Nic6XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VTMzg0JyAmJiBqd2suY3J2ICE9PSAnUC0zODQnOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFUzUxMicgJiYgandrLmNydiAhPT0gJ1AtNTIxJzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRWREU0EnICYmICEoandrLmNydiA9PT0gJ0VkMjU1MTknIHx8IGp3ay5jcnYgPT09ICdFZDQ0OCcpOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb25zdCB7IDA6IGp3aywgbGVuZ3RoIH0gPSBjYW5kaWRhdGVzO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGlmIChhZ2UgPj0gNjApIHtcbiAgICAgICAgICAgIGp3a3NDYWNoZS5kZWxldGUoYXMpO1xuICAgICAgICAgICAgcmV0dXJuIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2Vycm9yIHdoZW4gc2VsZWN0aW5nIGEgSldUIHZlcmlmaWNhdGlvbiBrZXksIG5vIGFwcGxpY2FibGUga2V5cyBmb3VuZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZXJyb3Igd2hlbiBzZWxlY3RpbmcgYSBKV1QgdmVyaWZpY2F0aW9uIGtleSwgbXVsdGlwbGUgYXBwbGljYWJsZSBrZXlzIGZvdW5kLCBhIFwia2lkXCIgSldUIEhlYWRlciBQYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgaW1wb3J0SndrKGFsZywgandrKTtcbiAgICBpZiAoa2V5LnR5cGUgIT09ICdwdWJsaWMnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2p3a3NfdXJpIG11c3Qgb25seSBjb250YWluIHB1YmxpYyBrZXlzJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG59XG5leHBvcnQgY29uc3Qgc2tpcFN1YmplY3RDaGVjayA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpPy5zcGxpdCgnOycpWzBdO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVc2VySW5mb1Jlc3BvbnNlKGFzLCBjbGllbnQsIGV4cGVjdGVkU3ViamVjdCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gVXNlckluZm8gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgbGV0IGpzb247XG4gICAgaWYgKGdldENvbnRlbnRUeXBlKHJlc3BvbnNlKSA9PT0gJ2FwcGxpY2F0aW9uL2p3dCcpIHtcbiAgICAgICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChhd2FpdCByZXNwb25zZS50ZXh0KCksIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLnVzZXJpbmZvX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQpLCBub1NpZ25hdHVyZUNoZWNrLCBnZXRDbG9ja1NrZXcoY2xpZW50KSwgZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlT3B0aW9uYWxBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZU9wdGlvbmFsSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKTtcbiAgICAgICAganNvbiA9IGNsYWltcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChjbGllbnQudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIFVzZXJJbmZvIFJlc3BvbnNlIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5zdWIpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwic3ViXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgc3dpdGNoIChleHBlY3RlZFN1YmplY3QpIHtcbiAgICAgICAgY2FzZSBza2lwU3ViamVjdENoZWNrOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGV4cGVjdGVkU3ViamVjdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImV4cGVjdGVkU3ViamVjdFwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbi5zdWIgIT09IGV4cGVjdGVkU3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgXCJyZXNwb25zZVwiIGJvZHkgXCJzdWJcIiB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsIG1ldGhvZCwgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgY2xpZW50QXV0aGVudGljYXRpb24oYXMsIGNsaWVudCwgYm9keSwgaGVhZGVycywgb3B0aW9ucz8uY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgIHJldHVybiAob3B0aW9ucz8uW2V4cGVyaW1lbnRhbF9jdXN0b21GZXRjaF0gfHwgZmV0Y2gpKHVybC5ocmVmLCB7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCA/IHNpZ25hbChvcHRpb25zLnNpZ25hbCkgOiBudWxsLFxuICAgIH0pLnRoZW4ocHJvY2Vzc0Rwb3BOb25jZSk7XG59XG5hc3luYyBmdW5jdGlvbiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCBncmFudFR5cGUsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICd0b2tlbl9lbmRwb2ludCcsIG9wdGlvbnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdncmFudF90eXBlJywgZ3JhbnRUeXBlKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBkcG9wUHJvb2ZKd3QoaGVhZGVycywgb3B0aW9ucy5EUG9QLCB1cmwsICdQT1NUJywgZ2V0Q2xvY2tTa2V3KGNsaWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIHBhcmFtZXRlcnMsIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdChhcywgY2xpZW50LCByZWZyZXNoVG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhyZWZyZXNoVG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVmcmVzaFRva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdyZWZyZXNoX3Rva2VuJywgcmVmcmVzaFRva2VuKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgJ3JlZnJlc2hfdG9rZW4nLCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbn1cbmNvbnN0IGlkVG9rZW5DbGFpbXMgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMocmVmKSB7XG4gICAgaWYgKCFyZWYuaWRfdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY2xhaW1zID0gaWRUb2tlbkNsYWltcy5nZXQocmVmKTtcbiAgICBpZiAoIWNsYWltcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlZlwiIHdhcyBhbHJlYWR5IGdhcmJhZ2UgY29sbGVjdGVkIG9yIGRpZCBub3QgcmVzb2x2ZSBmcm9tIHRoZSBwcm9wZXIgc291cmNlcycpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhaW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBpZ25vcmVJZFRva2VuID0gZmFsc2UsIGlnbm9yZVJlZnJlc2hUb2tlbiA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBUb2tlbiBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24uYWNjZXNzX3Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImFjY2Vzc190b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi50b2tlbl90eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInRva2VuX3R5cGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBqc29uLnRva2VuX3R5cGUgPSBqc29uLnRva2VuX3R5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoanNvbi50b2tlbl90eXBlICE9PSAnZHBvcCcgJiYganNvbi50b2tlbl90eXBlICE9PSAnYmVhcmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgYHRva2VuX3R5cGVgIHZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChqc29uLmV4cGlyZXNfaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAodHlwZW9mIGpzb24uZXhwaXJlc19pbiAhPT0gJ251bWJlcicgfHwganNvbi5leHBpcmVzX2luIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiZXhwaXJlc19pblwiIHByb3BlcnR5IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKCFpZ25vcmVSZWZyZXNoVG9rZW4gJiZcbiAgICAgICAganNvbi5yZWZyZXNoX3Rva2VuICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXZhbGlkYXRlU3RyaW5nKGpzb24ucmVmcmVzaF90b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJyZWZyZXNoX3Rva2VuXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKGpzb24uc2NvcGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5zY29wZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJzY29wZVwiIHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCFpZ25vcmVJZFRva2VuKSB7XG4gICAgICAgIGlmIChqc29uLmlkX3Rva2VuICE9PSB1bmRlZmluZWQgJiYgIXZhbGlkYXRlU3RyaW5nKGpzb24uaWRfdG9rZW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlkX3Rva2VuXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5pZF90b2tlbikge1xuICAgICAgICAgICAgY29uc3QgeyBjbGFpbXMgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGpzb24uaWRfdG9rZW4sIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLmlkX3Rva2VuX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQpLCBub1NpZ25hdHVyZUNoZWNrLCBnZXRDbG9ja1NrZXcoY2xpZW50KSwgZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KSlcbiAgICAgICAgICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBbJ2F1ZCcsICdleHAnLCAnaWF0JywgJ2lzcycsICdzdWInXSkpXG4gICAgICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzLmlzc3VlcikpXG4gICAgICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2xhaW1zLmF1ZCkgJiYgY2xhaW1zLmF1ZC5sZW5ndGggIT09IDEgJiYgY2xhaW1zLmF6cCAhPT0gY2xpZW50LmNsaWVudF9pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJhenBcIiAoYXV0aG9yaXplZCBwYXJ0eSkgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGllbnQucmVxdWlyZV9hdXRoX3RpbWUgJiYgdHlwZW9mIGNsYWltcy5hdXRoX3RpbWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcImF1dGhfdGltZVwiIChhdXRoZW50aWNhdGlvbiB0aW1lKSBjbGFpbSB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRUb2tlbkNsYWltcy5zZXQoanNvbiwgY2xhaW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUmVmcmVzaFRva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWxBdWRpZW5jZShleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5jbGFpbXMuYXVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlQXVkaWVuY2UoZXhwZWN0ZWQsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUF1ZGllbmNlKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQuY2xhaW1zLmF1ZCkpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQuY2xhaW1zLmF1ZC5pbmNsdWRlcyhleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYXVkXCIgKGF1ZGllbmNlKSBjbGFpbSB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdC5jbGFpbXMuYXVkICE9PSBleHBlY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWxJc3N1ZXIoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuY2xhaW1zLmlzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUlzc3VlcihleHBlY3RlZCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSXNzdWVyKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmNsYWltcy5pc3MgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiaXNzXCIgKGlzc3VlcikgY2xhaW0gdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGJyYW5kZWQgPSBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gYnJhbmQoc2VhcmNoUGFyYW1zKSB7XG4gICAgYnJhbmRlZC5hZGQoc2VhcmNoUGFyYW1zKTtcbiAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNhbGxiYWNrUGFyYW1ldGVycywgcmVkaXJlY3RVcmksIGNvZGVWZXJpZmllciwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWJyYW5kZWQuaGFzKGNhbGxiYWNrUGFyYW1ldGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1BhcmFtZXRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTFNlYXJjaFBhcmFtcyBvYnRhaW5lZCBmcm9tIFwidmFsaWRhdGVBdXRoUmVzcG9uc2UoKVwiLCBvciBcInZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKCknKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhyZWRpcmVjdFVyaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZWRpcmVjdFVyaVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoY29kZVZlcmlmaWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNvZGVWZXJpZmllclwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIoY2FsbGJhY2tQYXJhbWV0ZXJzLCAnY29kZScpO1xuICAgIGlmICghY29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdubyBhdXRob3JpemF0aW9uIGNvZGUgaW4gXCJjYWxsYmFja1BhcmFtZXRlcnNcIicpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ3JlZGlyZWN0X3VyaScsIHJlZGlyZWN0VXJpKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnY29kZV92ZXJpZmllcicsIGNvZGVWZXJpZmllcik7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2NvZGUnLCBjb2RlKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgJ2F1dGhvcml6YXRpb25fY29kZScsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xufVxuY29uc3Qgand0Q2xhaW1OYW1lcyA9IHtcbiAgICBhdWQ6ICdhdWRpZW5jZScsXG4gICAgY19oYXNoOiAnY29kZSBoYXNoJyxcbiAgICBjbGllbnRfaWQ6ICdjbGllbnQgaWQnLFxuICAgIGV4cDogJ2V4cGlyYXRpb24gdGltZScsXG4gICAgaWF0OiAnaXNzdWVkIGF0JyxcbiAgICBpc3M6ICdpc3N1ZXInLFxuICAgIGp0aTogJ2p3dCBpZCcsXG4gICAgbm9uY2U6ICdub25jZScsXG4gICAgc19oYXNoOiAnc3RhdGUgaGFzaCcsXG4gICAgc3ViOiAnc3ViamVjdCcsXG4gICAgYXRoOiAnYWNjZXNzIHRva2VuIGhhc2gnLFxuICAgIGh0bTogJ2h0dHAgbWV0aG9kJyxcbiAgICBodHU6ICdodHRwIHVyaScsXG4gICAgY25mOiAnY29uZmlybWF0aW9uJyxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVByZXNlbmNlKHJlcXVpcmVkLCByZXN1bHQpIHtcbiAgICBmb3IgKGNvbnN0IGNsYWltIG9mIHJlcXVpcmVkKSB7XG4gICAgICAgIGlmIChyZXN1bHQuY2xhaW1zW2NsYWltXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKGBKV1QgXCIke2NsYWltfVwiICgke2p3dENsYWltTmFtZXNbY2xhaW1dfSkgY2xhaW0gbWlzc2luZ2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgZXhwZWN0Tm9Ob25jZSA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IHNraXBBdXRoVGltZUNoZWNrID0gU3ltYm9sKCk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT3BlbklEUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIGV4cGVjdGVkTm9uY2UsIG1heEFnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG4gICAgaWYgKGlzT0F1dGgyRXJyb3IocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHJlc3VsdC5pZF90b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpZF90b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIG1heEFnZSA/PyAobWF4QWdlID0gY2xpZW50LmRlZmF1bHRfbWF4X2FnZSA/PyBza2lwQXV0aFRpbWVDaGVjayk7XG4gICAgY29uc3QgY2xhaW1zID0gZ2V0VmFsaWRhdGVkSWRUb2tlbkNsYWltcyhyZXN1bHQpO1xuICAgIGlmICgoY2xpZW50LnJlcXVpcmVfYXV0aF90aW1lIHx8IG1heEFnZSAhPT0gc2tpcEF1dGhUaW1lQ2hlY2spICYmXG4gICAgICAgIGNsYWltcy5hdXRoX3RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdJRCBUb2tlbiBcImF1dGhfdGltZVwiIChhdXRoZW50aWNhdGlvbiB0aW1lKSBjbGFpbSBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmIChtYXhBZ2UgIT09IHNraXBBdXRoVGltZUNoZWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJyB8fCBtYXhBZ2UgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMubWF4X2FnZVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KTtcbiAgICAgICAgaWYgKGNsYWltcy5hdXRoX3RpbWUgKyBtYXhBZ2UgPCBub3cgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3RvbyBtdWNoIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgRW5kLVVzZXIgYXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKGV4cGVjdGVkTm9uY2UpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgZXhwZWN0Tm9Ob25jZTpcbiAgICAgICAgICAgIGlmIChjbGFpbXMubm9uY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWROb25jZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4cGVjdGVkTm9uY2VcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYWltcy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGFpbXMubm9uY2UgIT09IGV4cGVjdGVkTm9uY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwibm9uY2VcIiBjbGFpbSB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9BdXRoMlJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCB0cnVlKTtcbiAgICBpZiAoaXNPQXV0aDJFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuaWRfdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5pZF90b2tlbiA9PT0gJ3N0cmluZycgJiYgcmVzdWx0LmlkX3Rva2VuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnVW5leHBlY3RlZCBJRCBUb2tlbiByZXR1cm5lZCwgdXNlIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9wZW5JRFJlc3BvbnNlKCkgZm9yIE9wZW5JRCBDb25uZWN0IGNhbGxiYWNrIHByb2Nlc3NpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgcmVzdWx0LmlkX3Rva2VuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hlY2tKd3RUeXBlKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAodHlwZW9mIHJlc3VsdC5oZWFkZXIudHlwICE9PSAnc3RyaW5nJyB8fCBub3JtYWxpemVUeXAocmVzdWx0LmhlYWRlci50eXApICE9PSBleHBlY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcInR5cFwiIGhlYWRlciBwYXJhbWV0ZXIgdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGllbnRDcmVkZW50aWFsc0dyYW50UmVxdWVzdChhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCAnY2xpZW50X2NyZWRlbnRpYWxzJywgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKSwgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NsaWVudENyZWRlbnRpYWxzUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHRydWUsIHRydWUpO1xuICAgIGlmIChpc09BdXRoMkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXZvY2F0aW9uUmVxdWVzdChhcywgY2xpZW50LCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAncmV2b2NhdGlvbl9lbmRwb2ludCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgndG9rZW4nLCB0b2tlbik7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuZGVsZXRlKCdhY2NlcHQnKTtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NSZXZvY2F0aW9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gUmV2b2NhdGlvbiBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgYm9keSBoYXMgYmVlbiB1c2VkIGFscmVhZHknKTtcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW50cm9zcGVjdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgdG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyh0b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0b2tlblwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ2ludHJvc3BlY3Rpb25fZW5kcG9pbnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBpZiAob3B0aW9ucz8ucmVxdWVzdEp3dFJlc3BvbnNlID8/IGNsaWVudC5pbnRyb3NwZWN0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi90b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCAnUE9TVCcsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ludHJvc3BlY3Rpb25SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gSW50cm9zcGVjdGlvbiBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICBsZXQganNvbjtcbiAgICBpZiAoZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpID09PSAnYXBwbGljYXRpb24vdG9rZW4taW50cm9zcGVjdGlvbitqd3QnKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoYXdhaXQgcmVzcG9uc2UudGV4dCgpLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pbnRyb3NwZWN0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLmludHJvc3BlY3Rpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIG5vU2lnbmF0dXJlQ2hlY2ssIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAgICAgLnRoZW4oY2hlY2tKd3RUeXBlLmJpbmQodW5kZWZpbmVkLCAndG9rZW4taW50cm9zcGVjdGlvbitqd3QnKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnYXVkJywgJ2lhdCcsICdpc3MnXSkpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICAgICAganNvbiA9IGNsYWltcy50b2tlbl9pbnRyb3NwZWN0aW9uO1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIFwidG9rZW5faW50cm9zcGVjdGlvblwiIGNsYWltIG11c3QgYmUgYSBKU09OIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uLmFjdGl2ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiYWN0aXZlXCIgcHJvcGVydHkgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBqd2tzUmVxdWVzdChhcywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdqd2tzX3VyaScpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBoZWFkZXJzLmFwcGVuZCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3ay1zZXQranNvbicpO1xuICAgIHJldHVybiAob3B0aW9ucz8uW2V4cGVyaW1lbnRhbF9jdXN0b21GZXRjaF0gfHwgZmV0Y2gpKHVybC5ocmVmLCB7XG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgPyBzaWduYWwob3B0aW9ucy5zaWduYWwpIDogbnVsbCxcbiAgICB9KS50aGVuKHByb2Nlc3NEcG9wTm9uY2UpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0p3a3NSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIEpTT04gV2ViIEtleSBTZXQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ua2V5cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJrZXlzXCIgcHJvcGVydHkgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LnByb3RvdHlwZS5ldmVyeS5jYWxsKGpzb24ua2V5cywgaXNKc29uT2JqZWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImtleXNcIiBwcm9wZXJ0eSBtZW1iZXJzIG11c3QgYmUgSldLIGZvcm1hdHRlZCBvYmplY3RzJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID4gMzk5ICYmIHJlc3BvbnNlLnN0YXR1cyA8IDUwMCkge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXNKc29uT2JqZWN0KGpzb24pICYmIHR5cGVvZiBqc29uLmVycm9yID09PSAnc3RyaW5nJyAmJiBqc29uLmVycm9yLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLmVycm9yX2Rlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uZXJyb3JfZGVzY3JpcHRpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNvbi5lcnJvcl91cmkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5lcnJvcl91cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmVycm9yX3VyaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uYWxncyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLmFsZ3MgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmFsZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc29uLnNjb3BlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uc2NvcGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLnNjb3BlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNoZWNrU3VwcG9ydGVkSndzQWxnKGFsZykge1xuICAgIGlmICghU1VQUE9SVEVEX0pXU19BTEdTLmluY2x1ZGVzKGFsZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXUyBcImFsZ1wiIGlkZW50aWZpZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsZztcbn1cbmZ1bmN0aW9uIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGFsZ29yaXRobSkge1xuICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggIT09ICdudW1iZXInIHx8IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoIDwgMjA0OCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKGAke2FsZ29yaXRobS5uYW1lfSBtb2R1bHVzTGVuZ3RoIG11c3QgYmUgYXQgbGVhc3QgMjA0OCBiaXRzYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZWNkc2FIYXNoTmFtZShuYW1lZEN1cnZlKSB7XG4gICAgc3dpdGNoIChuYW1lZEN1cnZlKSB7XG4gICAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTI1Nic7XG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTM4NCc7XG4gICAgICAgIGNhc2UgJ1AtNTIxJzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleVRvU3VidGxlKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ0VDRFNBJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZToga2V5LmFsZ29yaXRobS5uYW1lLFxuICAgICAgICAgICAgICAgIGhhc2g6IGVjZHNhSGFzaE5hbWUoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ1JTQS1QU1MnOiB7XG4gICAgICAgICAgICBjaGVja1JzYUtleUFsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtNTEyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleS5hbGdvcml0aG0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbHRMZW5ndGg6IHBhcnNlSW50KGtleS5hbGdvcml0aG0uaGFzaC5uYW1lLnNsaWNlKC0zKSwgMTApID4+IDMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSU0FTU0EtUEtDUzEtdjFfNSc6XG4gICAgICAgICAgICBjaGVja1JzYUtleUFsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgICAgIHJldHVybiBrZXkuYWxnb3JpdGhtLm5hbWU7XG4gICAgICAgIGNhc2UgJ0VkNDQ4JzpcbiAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgICAgICByZXR1cm4ga2V5LmFsZ29yaXRobS5uYW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xufVxuY29uc3Qgbm9TaWduYXR1cmVDaGVjayA9IFN5bWJvbCgpO1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVKd3QoandzLCBjaGVja0FsZywgZ2V0S2V5LCBjbG9ja1NrZXcsIGNsb2NrVG9sZXJhbmNlKSB7XG4gICAgY29uc3QgeyAwOiBwcm90ZWN0ZWRIZWFkZXIsIDE6IHBheWxvYWQsIDI6IGVuY29kZWRTaWduYXR1cmUsIGxlbmd0aCB9ID0gandzLnNwbGl0KCcuJyk7XG4gICAgaWYgKGxlbmd0aCA9PT0gNSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcignSldFIHN0cnVjdHVyZSBKV1RzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSW52YWxpZCBKV1QnKTtcbiAgICB9XG4gICAgbGV0IGhlYWRlcjtcbiAgICB0cnkge1xuICAgICAgICBoZWFkZXIgPSBKU09OLnBhcnNlKGJ1ZihiNjR1KHByb3RlY3RlZEhlYWRlcikpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBKV1QgSGVhZGVyIGJvZHkgYXMgYmFzZTY0dXJsIGVuY29kZWQgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGhlYWRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIEhlYWRlciBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBjaGVja0FsZyhoZWFkZXIpO1xuICAgIGlmIChoZWFkZXIuY3JpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiY3JpdFwiIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYjY0dShlbmNvZGVkU2lnbmF0dXJlKTtcbiAgICBsZXQga2V5O1xuICAgIGlmIChnZXRLZXkgIT09IG5vU2lnbmF0dXJlQ2hlY2spIHtcbiAgICAgICAga2V5ID0gYXdhaXQgZ2V0S2V5KGhlYWRlcik7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYCR7cHJvdGVjdGVkSGVhZGVyfS4ke3BheWxvYWR9YDtcbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShrZXlUb1N1YnRsZShrZXkpLCBrZXksIHNpZ25hdHVyZSwgYnVmKGlucHV0KSk7XG4gICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjbGFpbXM7XG4gICAgdHJ5IHtcbiAgICAgICAgY2xhaW1zID0gSlNPTi5wYXJzZShidWYoYjY0dShwYXlsb2FkKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIEpXVCBQYXlsb2FkIGJvZHkgYXMgYmFzZTY0dXJsIGVuY29kZWQgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIFBheWxvYWQgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBjbG9ja1NrZXc7XG4gICAgaWYgKGNsYWltcy5leHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5leHAgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImV4cFwiIChleHBpcmF0aW9uIHRpbWUpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLmV4cCA8PSBub3cgLSBjbG9ja1RvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSB2YWx1ZSwgdGltZXN0YW1wIGlzIDw9IG5vdygpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5pYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5pYXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlhdFwiIChpc3N1ZWQgYXQpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLmlzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmlzcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiaXNzXCIgKGlzc3VlcikgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMubmJmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMubmJmICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJuYmZcIiAobm90IGJlZm9yZSkgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMubmJmID4gbm93ICsgY2xvY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwibmJmXCIgKG5vdCBiZWZvcmUpIGNsYWltIHZhbHVlLCB0aW1lc3RhbXAgaXMgPiBub3coKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuYXVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuYXVkICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBoZWFkZXIsIGNsYWltcywgc2lnbmF0dXJlLCBrZXkgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZFN0YXRlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmIChwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMsIG9yIFVSTCcpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAncmVzcG9uc2UnKTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicGFyYW1ldGVyc1wiIGRvZXMgbm90IGNvbnRhaW4gYSBKQVJNIHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXMuandrc191cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMuandrc191cmlcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChyZXNwb25zZSwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy5hdXRob3JpemF0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQpLCBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaS5iaW5kKHVuZGVmaW5lZCwgYXMsIG9wdGlvbnMpLCBnZXRDbG9ja1NrZXcoY2xpZW50KSwgZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnZXhwJywgJ2lzcyddKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzLmlzc3VlcikpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2xhaW1zKSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBrZXkgIT09ICdhdWQnKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZUF1dGhSZXNwb25zZShhcywgY2xpZW50LCByZXN1bHQsIGV4cGVjdGVkU3RhdGUpO1xufVxuYXN5bmMgZnVuY3Rpb24gaWRUb2tlbkhhc2goYWxnLCBkYXRhLCBrZXkpIHtcbiAgICBsZXQgYWxnb3JpdGhtO1xuICAgIHN3aXRjaCAoYWxnKSB7XG4gICAgICAgIGNhc2UgJ1JTMjU2JzpcbiAgICAgICAgY2FzZSAnUFMyNTYnOlxuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgICAgICBhbGdvcml0aG0gPSAnU0hBLTI1Nic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUlMzODQnOlxuICAgICAgICBjYXNlICdQUzM4NCc6XG4gICAgICAgIGNhc2UgJ0VTMzg0JzpcbiAgICAgICAgICAgIGFsZ29yaXRobSA9ICdTSEEtMzg0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSUzUxMic6XG4gICAgICAgIGNhc2UgJ1BTNTEyJzpcbiAgICAgICAgY2FzZSAnRVM1MTInOlxuICAgICAgICAgICAgYWxnb3JpdGhtID0gJ1NIQS01MTInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VkRFNBJzpcbiAgICAgICAgICAgIGlmIChrZXkuYWxnb3JpdGhtLm5hbWUgPT09ICdFZDI1NTE5Jykge1xuICAgICAgICAgICAgICAgIGFsZ29yaXRobSA9ICdTSEEtNTEyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBkaWdlc3QgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChhbGdvcml0aG0sIGJ1ZihkYXRhKSk7XG4gICAgcmV0dXJuIGI2NHUoZGlnZXN0LnNsaWNlKDAsIGRpZ2VzdC5ieXRlTGVuZ3RoIC8gMikpO1xufVxuYXN5bmMgZnVuY3Rpb24gaWRUb2tlbkhhc2hNYXRjaGVzKGRhdGEsIGFjdHVhbCwgYWxnLCBrZXkpIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IGF3YWl0IGlkVG9rZW5IYXNoKGFsZywgZGF0YSwga2V5KTtcbiAgICByZXR1cm4gYWN0dWFsID09PSBleHBlY3RlZDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBlcmltZW50YWxfdmFsaWRhdGVEZXRhY2hlZFNpZ25hdHVyZVJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBpZiAoIXBhcmFtZXRlcnMuaGFzaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIGFzIGFuIGluc3RhbmNlIG9mIFVSTCBtdXN0IGNvbnRhaW4gYSBoYXNoIChmcmFnbWVudCkgd2l0aCB0aGUgQXV0aG9yaXphdGlvbiBSZXNwb25zZSBwYXJhbWV0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycy5oYXNoLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMnKTtcbiAgICB9XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgY29uc3QgaWRfdG9rZW4gPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2lkX3Rva2VuJyk7XG4gICAgcGFyYW1ldGVycy5kZWxldGUoJ2lkX3Rva2VuJyk7XG4gICAgc3dpdGNoIChleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlIGV4cGVjdE5vU3RhdGU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWRTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4cGVjdGVkU3RhdGVcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZUF1dGhSZXNwb25zZSh7XG4gICAgICAgIC4uLmFzLFxuICAgICAgICBhdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkOiBmYWxzZSxcbiAgICB9LCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkU3RhdGUpO1xuICAgIGlmIChpc09BdXRoMkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKCFpZF90b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInBhcmFtZXRlcnNcIiBkb2VzIG5vdCBjb250YWluIGFuIElEIFRva2VuJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2NvZGUnKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJwYXJhbWV0ZXJzXCIgZG9lcyBub3QgY29udGFpbiBhbiBBdXRob3JpemF0aW9uIENvZGUnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcy5qd2tzX3VyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhcy5qd2tzX3VyaVwiIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZWRDbGFpbXMgPSBbXG4gICAgICAgICdhdWQnLFxuICAgICAgICAnZXhwJyxcbiAgICAgICAgJ2lhdCcsXG4gICAgICAgICdpc3MnLFxuICAgICAgICAnc3ViJyxcbiAgICAgICAgJ25vbmNlJyxcbiAgICAgICAgJ2NfaGFzaCcsXG4gICAgXTtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkU3RhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlcXVpcmVkQ2xhaW1zLnB1c2goJ3NfaGFzaCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYWltcywgaGVhZGVyLCBrZXkgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGlkX3Rva2VuLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy5pZF90b2tlbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkuYmluZCh1bmRlZmluZWQsIGFzLCBvcHRpb25zKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIHJlcXVpcmVkQ2xhaW1zKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzLmlzc3VlcikpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICBjb25zdCBjbG9ja1NrZXcgPSBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGNsb2NrU2tldztcbiAgICBpZiAoY2xhaW1zLmlhdCA8IG5vdyAtIDM2MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpYXRcIiAoaXNzdWVkIGF0KSBjbGFpbSB2YWx1ZSwgaXQgaXMgdG9vIGZhciBpbiB0aGUgcGFzdCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNsYWltcy5jX2hhc2ggIT09ICdzdHJpbmcnIHx8XG4gICAgICAgIChhd2FpdCBpZFRva2VuSGFzaE1hdGNoZXMoY29kZSwgY2xhaW1zLmNfaGFzaCwgaGVhZGVyLmFsZywga2V5KSkgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnaW52YWxpZCBJRCBUb2tlbiBcImNfaGFzaFwiIChjb2RlIGhhc2gpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChjbGFpbXMuc19oYXNoICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGV4cGVjdGVkU3RhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2NvdWxkIG5vdCB2ZXJpZnkgSUQgVG9rZW4gXCJzX2hhc2hcIiAoc3RhdGUgaGFzaCkgY2xhaW0gdmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZFN0YXRlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAodHlwZW9mIGNsYWltcy5zX2hhc2ggIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoYXdhaXQgaWRUb2tlbkhhc2hNYXRjaGVzKGV4cGVjdGVkU3RhdGUsIGNsYWltcy5zX2hhc2gsIGhlYWRlci5hbGcsIGtleSkpICE9PSB0cnVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdpbnZhbGlkIElEIFRva2VuIFwic19oYXNoXCIgKHN0YXRlIGhhc2gpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChjbGllbnQucmVxdWlyZV9hdXRoX3RpbWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY2xhaW1zLmF1dGhfdGltZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcImF1dGhfdGltZVwiIChhdXRoZW50aWNhdGlvbiB0aW1lKSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICBtYXhBZ2UgPz8gKG1heEFnZSA9IGNsaWVudC5kZWZhdWx0X21heF9hZ2UgPz8gc2tpcEF1dGhUaW1lQ2hlY2spO1xuICAgIGlmICgoY2xpZW50LnJlcXVpcmVfYXV0aF90aW1lIHx8IG1heEFnZSAhPT0gc2tpcEF1dGhUaW1lQ2hlY2spICYmXG4gICAgICAgIGNsYWltcy5hdXRoX3RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdJRCBUb2tlbiBcImF1dGhfdGltZVwiIChhdXRoZW50aWNhdGlvbiB0aW1lKSBjbGFpbSBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmIChtYXhBZ2UgIT09IHNraXBBdXRoVGltZUNoZWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJyB8fCBtYXhBZ2UgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMubWF4X2FnZVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KTtcbiAgICAgICAgaWYgKGNsYWltcy5hdXRoX3RpbWUgKyBtYXhBZ2UgPCBub3cgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3RvbyBtdWNoIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgRW5kLVVzZXIgYXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGV4cGVjdGVkTm9uY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXhwZWN0ZWROb25jZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChjbGFpbXMubm9uY2UgIT09IGV4cGVjdGVkTm9uY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gdmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2xhaW1zLmF1ZCkgJiYgY2xhaW1zLmF1ZC5sZW5ndGggIT09IDEgJiYgY2xhaW1zLmF6cCAhPT0gY2xpZW50LmNsaWVudF9pZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwiYXpwXCIgKGF1dGhvcml6ZWQgcGFydHkpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGVja1NpZ25pbmdBbGdvcml0aG0oY2xpZW50LCBpc3N1ZXIsIGhlYWRlcikge1xuICAgIGlmIChjbGllbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaGVhZGVyLmFsZyAhPT0gY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlzc3VlcikpIHtcbiAgICAgICAgaWYgKCFpc3N1ZXIuaW5jbHVkZXMoaGVhZGVyLmFsZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGhlYWRlci5hbGcgIT09ICdSUzI1NicpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhbGdcIiBoZWFkZXIgcGFyYW1ldGVyJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsIG5hbWUpIHtcbiAgICBjb25zdCB7IDA6IHZhbHVlLCBsZW5ndGggfSA9IHBhcmFtZXRlcnMuZ2V0QWxsKG5hbWUpO1xuICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoYFwiJHtuYW1lfVwiIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkIG9ubHkgb25jZWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgY29uc3Qgc2tpcFN0YXRlQ2hlY2sgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBleHBlY3ROb1N0YXRlID0gU3ltYm9sKCk7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBdXRoUmVzcG9uc2UoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgZXhwZWN0ZWRTdGF0ZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5zZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGlmICghKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zLCBvciBVUkwnKTtcbiAgICB9XG4gICAgaWYgKGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAncmVzcG9uc2UnKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInBhcmFtZXRlcnNcIiBjb250YWlucyBhIEpBUk0gcmVzcG9uc2UsIHVzZSB2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSgpIGluc3RlYWQgb2YgdmFsaWRhdGVBdXRoUmVzcG9uc2UoKScpO1xuICAgIH1cbiAgICBjb25zdCBpc3MgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2lzcycpO1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdzdGF0ZScpO1xuICAgIGlmICghaXNzICYmIGFzLmF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgncmVzcG9uc2UgcGFyYW1ldGVyIFwiaXNzXCIgKGlzc3VlcikgbWlzc2luZycpO1xuICAgIH1cbiAgICBpZiAoaXNzICYmIGlzcyAhPT0gYXMuaXNzdWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgXCJpc3NcIiAoaXNzdWVyKSByZXNwb25zZSBwYXJhbWV0ZXIgdmFsdWUnKTtcbiAgICB9XG4gICAgc3dpdGNoIChleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlIGV4cGVjdE5vU3RhdGU6XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgXCJzdGF0ZVwiIHJlc3BvbnNlIHBhcmFtZXRlciBlbmNvdW50ZXJlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc2tpcFN0YXRlQ2hlY2s6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWRTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImV4cGVjdGVkU3RhdGVcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdyZXNwb25zZSBwYXJhbWV0ZXIgXCJzdGF0ZVwiIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gZXhwZWN0ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgXCJzdGF0ZVwiIHJlc3BvbnNlIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnZXJyb3InKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JfZGVzY3JpcHRpb246IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnZXJyb3JfZGVzY3JpcHRpb24nKSxcbiAgICAgICAgICAgIGVycm9yX3VyaTogZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcl91cmknKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaWRfdG9rZW4gPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2lkX3Rva2VuJyk7XG4gICAgY29uc3QgdG9rZW4gPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3Rva2VuJyk7XG4gICAgaWYgKGlkX3Rva2VuICE9PSB1bmRlZmluZWQgfHwgdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcignaW1wbGljaXQgYW5kIGh5YnJpZCBmbG93cyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYnJhbmQobmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKSk7XG59XG5mdW5jdGlvbiBhbGdUb1N1YnRsZShhbGcsIGNydikge1xuICAgIHN3aXRjaCAoYWxnKSB7XG4gICAgICAgIGNhc2UgJ1BTMjU2JzpcbiAgICAgICAgY2FzZSAnUFMzODQnOlxuICAgICAgICBjYXNlICdQUzUxMic6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnUlNBLVBTUycsIGhhc2g6IGBTSEEtJHthbGcuc2xpY2UoLTMpfWAgfTtcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICBjYXNlICdSUzM4NCc6XG4gICAgICAgIGNhc2UgJ1JTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsIGhhc2g6IGBTSEEtJHthbGcuc2xpY2UoLTMpfWAgfTtcbiAgICAgICAgY2FzZSAnRVMyNTYnOlxuICAgICAgICBjYXNlICdFUzM4NCc6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnRUNEU0EnLCBuYW1lZEN1cnZlOiBgUC0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdFUzUxMic6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnRUNEU0EnLCBuYW1lZEN1cnZlOiAnUC01MjEnIH07XG4gICAgICAgIGNhc2UgJ0VkRFNBJzoge1xuICAgICAgICAgICAgc3dpdGNoIChjcnYpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdFZDQ0OCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnY7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbXBvcnRKd2soYWxnLCBqd2spIHtcbiAgICBjb25zdCB7IGV4dCwga2V5X29wcywgdXNlLCAuLi5rZXkgfSA9IGp3aztcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIGtleSwgYWxnVG9TdWJ0bGUoYWxnLCBqd2suY3J2KSwgdHJ1ZSwgWyd2ZXJpZnknXSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV2aWNlQXV0aG9yaXphdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdkZXZpY2VfYXV0aG9yaXphdGlvbl9lbmRwb2ludCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGV2aWNlQXV0aG9yaXphdGlvblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBEZXZpY2UgQXV0aG9yaXphdGlvbiBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24uZGV2aWNlX2NvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiZGV2aWNlX2NvZGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24udXNlcl9jb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInVzZXJfY29kZVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi52ZXJpZmljYXRpb25fdXJpKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInZlcmlmaWNhdGlvbl91cmlcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24uZXhwaXJlc19pbiAhPT0gJ251bWJlcicgfHwganNvbi5leHBpcmVzX2luIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJleHBpcmVzX2luXCIgcHJvcGVydHkgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAoanNvbi52ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXZhbGlkYXRlU3RyaW5nKGpzb24udmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ2ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKGpzb24uaW50ZXJ2YWwgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIGpzb24uaW50ZXJ2YWwgIT09ICdudW1iZXInIHx8IGpzb24uaW50ZXJ2YWwgPD0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpbnRlcnZhbFwiIHByb3BlcnR5IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV2aWNlQ29kZUdyYW50UmVxdWVzdChhcywgY2xpZW50LCBkZXZpY2VDb2RlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZGV2aWNlQ29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZXZpY2VDb2RlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdkZXZpY2VfY29kZScsIGRldmljZUNvZGUpO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmdyYW50LXR5cGU6ZGV2aWNlX2NvZGUnLCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGV2aWNlQ29kZVJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVLZXlQYWlyKGFsZywgb3B0aW9ucykge1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoYWxnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFsZ1wiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IGFsZ29yaXRobSA9IGFsZ1RvU3VidGxlKGFsZywgYWxnID09PSAnRWREU0EnID8gb3B0aW9ucz8uY3J2ID8/ICdFZDI1NTE5JyA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKGFsZy5zdGFydHNXaXRoKCdQUycpIHx8IGFsZy5zdGFydHNXaXRoKCdSUycpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWxnb3JpdGhtLCB7XG4gICAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBvcHRpb25zPy5tb2R1bHVzTGVuZ3RoID8/IDIwNDgsXG4gICAgICAgICAgICBwdWJsaWNFeHBvbmVudDogbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIDB4MDAsIDB4MDFdKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleShhbGdvcml0aG0sIG9wdGlvbnM/LmV4dHJhY3RhYmxlID8/IGZhbHNlLCBbJ3NpZ24nLCAndmVyaWZ5J10pKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUh0dShodHUpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGh0dSk7XG4gICAgdXJsLnNlYXJjaCA9ICcnO1xuICAgIHVybC5oYXNoID0gJyc7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVEUG9QKGFzLCByZXF1ZXN0LCBhY2Nlc3NUb2tlbkNsYWltcywgb3B0aW9ucykge1xuICAgIGlmICghcmVxdWVzdC5oZWFkZXJzLmhhcygnZHBvcCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ29wZXJhdGlvbiBpbmRpY2F0ZWQgRFBvUCB1c2UgYnV0IHRoZSByZXF1ZXN0IGhhcyBubyBEUG9QIEhUVFAgSGVhZGVyJyk7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LmhlYWRlcnMuZ2V0KCdhdXRob3JpemF0aW9uJyk/LnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZHBvcCAnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRShgb3BlcmF0aW9uIGluZGljYXRlZCBEUG9QIHVzZSBidXQgdGhlIHJlcXVlc3QncyBBdXRob3JpemF0aW9uIEhUVFAgSGVhZGVyIHNjaGVtZSBpcyBub3QgRFBvUGApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjY2Vzc1Rva2VuQ2xhaW1zLmNuZj8uamt0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdvcGVyYXRpb24gaW5kaWNhdGVkIERQb1AgdXNlIGJ1dCB0aGUgSldUIEFjY2VzcyBUb2tlbiBoYXMgbm8gamt0IGNvbmZpcm1hdGlvbiBjbGFpbScpO1xuICAgIH1cbiAgICBjb25zdCBjbG9ja1NrZXcgPSBnZXRDbG9ja1NrZXcob3B0aW9ucyk7XG4gICAgY29uc3QgcHJvb2YgPSBhd2FpdCB2YWxpZGF0ZUp3dChyZXF1ZXN0LmhlYWRlcnMuZ2V0KCdkcG9wJyksIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcz8uZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIHx8IFNVUFBPUlRFRF9KV1NfQUxHUyksIGFzeW5jICh7IGp3aywgYWxnIH0pID0+IHtcbiAgICAgICAgaWYgKCFqd2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0RQb1AgUHJvb2YgaXMgbWlzc2luZyB0aGUgandrIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBpbXBvcnRKd2soYWxnLCBqd2spO1xuICAgICAgICBpZiAoa2V5LnR5cGUgIT09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdEUG9QIFByb29mIGp3ayBoZWFkZXIgcGFyYW1ldGVyIG11c3QgY29udGFpbiBhIHB1YmxpYyBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH0sIGNsb2NrU2tldywgZ2V0Q2xvY2tUb2xlcmFuY2Uob3B0aW9ucykpXG4gICAgICAgIC50aGVuKGNoZWNrSnd0VHlwZS5iaW5kKHVuZGVmaW5lZCwgJ2Rwb3Arand0JykpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnaWF0JywgJ2p0aScsICdhdGgnLCAnaHRtJywgJ2h0dSddKSk7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBjbG9ja1NrZXc7XG4gICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKG5vdyAtIHByb29mLmNsYWltcy5pYXQpO1xuICAgIGlmIChkaWZmID4gMzAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0RQb1AgUHJvb2YgaWF0IGlzIG5vdCByZWNlbnQgZW5vdWdoJyk7XG4gICAgfVxuICAgIGlmIChwcm9vZi5jbGFpbXMuaHRtICE9PSByZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdEUG9QIFByb29mIGh0bSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb29mLmNsYWltcy5odHUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgIG5vcm1hbGl6ZUh0dShwcm9vZi5jbGFpbXMuaHR1KSAhPT0gbm9ybWFsaXplSHR1KHJlcXVlc3QudXJsKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdEUG9QIFByb29mIGh0dSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpLnNwbGl0KCcgJylbMV07XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkID0gYjY0dShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGVuY29kZXIuZW5jb2RlKGFjY2Vzc1Rva2VuKSkpO1xuICAgICAgICBpZiAocHJvb2YuY2xhaW1zLmF0aCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0RQb1AgUHJvb2YgYXRoIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgICBsZXQgY29tcG9uZW50cztcbiAgICAgICAgc3dpdGNoIChwcm9vZi5oZWFkZXIuandrLmt0eSkge1xuICAgICAgICAgICAgY2FzZSAnRUMnOlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNydjogcHJvb2YuaGVhZGVyLmp3ay5jcnYsXG4gICAgICAgICAgICAgICAgICAgIGt0eTogcHJvb2YuaGVhZGVyLmp3ay5rdHksXG4gICAgICAgICAgICAgICAgICAgIHg6IHByb29mLmhlYWRlci5qd2sueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcHJvb2YuaGVhZGVyLmp3ay55LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdPS1AnOlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNydjogcHJvb2YuaGVhZGVyLmp3ay5jcnYsXG4gICAgICAgICAgICAgICAgICAgIGt0eTogcHJvb2YuaGVhZGVyLmp3ay5rdHksXG4gICAgICAgICAgICAgICAgICAgIHg6IHByb29mLmhlYWRlci5qd2sueCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUlNBJzpcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBlOiBwcm9vZi5oZWFkZXIuandrLmUsXG4gICAgICAgICAgICAgICAgICAgIGt0eTogcHJvb2YuaGVhZGVyLmp3ay5rdHksXG4gICAgICAgICAgICAgICAgICAgIG46IHByb29mLmhlYWRlci5qd2subixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkID0gYjY0dShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGNvbXBvbmVudHMpKSkpO1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW5DbGFpbXMuY25mLmprdCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBBY2Nlc3MgVG9rZW4gY29uZmlybWF0aW9uIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwZXJpbWVudGFsX3ZhbGlkYXRlSnd0QWNjZXNzVG9rZW4oYXMsIHJlcXVlc3QsIGV4cGVjdGVkQXVkaWVuY2UsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVxdWVzdCwgUmVxdWVzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXF1ZXN0XCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXF1ZXN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWRBdWRpZW5jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJleHBlY3RlZEF1ZGllbmNlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoIWF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXF1ZXN0XCIgaXMgbWlzc2luZyBhbiBBdXRob3JpemF0aW9uIEhUVFAgSGVhZGVyJyk7XG4gICAgfVxuICAgIGxldCB7IDA6IHNjaGVtZSwgMTogYWNjZXNzVG9rZW4sIGxlbmd0aCB9ID0gYXV0aG9yaXphdGlvbi5zcGxpdCgnICcpO1xuICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgIGNhc2UgJ2Rwb3AnOlxuICAgICAgICBjYXNlICdiZWFyZXInOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgQXV0aG9yaXphdGlvbiBIVFRQIEhlYWRlciBzY2hlbWUnKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdpbnZhbGlkIEF1dGhvcml6YXRpb24gSFRUUCBIZWFkZXIgZm9ybWF0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVpcmVkQ2xhaW1zID0gW1xuICAgICAgICAnaXNzJyxcbiAgICAgICAgJ2V4cCcsXG4gICAgICAgICdhdWQnLFxuICAgICAgICAnc3ViJyxcbiAgICAgICAgJ2lhdCcsXG4gICAgICAgICdqdGknLFxuICAgICAgICAnY2xpZW50X2lkJyxcbiAgICBdO1xuICAgIGlmIChvcHRpb25zPy5yZXF1aXJlRFBvUCB8fCBzY2hlbWUgPT09ICdkcG9wJyB8fCByZXF1ZXN0LmhlYWRlcnMuaGFzKCdkcG9wJykpIHtcbiAgICAgICAgcmVxdWlyZWRDbGFpbXMucHVzaCgnY25mJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChhY2Nlc3NUb2tlbiwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCB1bmRlZmluZWQsIFNVUFBPUlRFRF9KV1NfQUxHUyksIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpLmJpbmQodW5kZWZpbmVkLCBhcywgb3B0aW9ucyksIGdldENsb2NrU2tldyhvcHRpb25zKSwgZ2V0Q2xvY2tUb2xlcmFuY2Uob3B0aW9ucykpXG4gICAgICAgIC50aGVuKGNoZWNrSnd0VHlwZS5iaW5kKHVuZGVmaW5lZCwgJ2F0K2p3dCcpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCByZXF1aXJlZENsYWltcykpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBleHBlY3RlZEF1ZGllbmNlKSk7XG4gICAgZm9yIChjb25zdCBjbGFpbSBvZiBbJ2NsaWVudF9pZCcsICdqdGknLCAnc3ViJ10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXNbY2xhaW1dICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRShgdW5leHBlY3RlZCBKV1QgXCIke2NsYWltfVwiIGNsYWltIHR5cGVgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ2NuZicgaW4gY2xhaW1zKSB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcy5jbmYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImNuZlwiIChjb25maXJtYXRpb24pIGNsYWltIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyAwOiBjbmYsIGxlbmd0aCB9ID0gT2JqZWN0LmtleXMoY2xhaW1zLmNuZik7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcignbXVsdGlwbGUgY29uZmlybWF0aW9uIGNsYWltcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNuZiAhPT0gJ2prdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgSldUIENvbmZpcm1hdGlvbiBtZXRob2QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ucmVxdWlyZURQb1AgfHxcbiAgICAgICAgc2NoZW1lID09PSAnZHBvcCcgfHxcbiAgICAgICAgY2xhaW1zLmNuZj8uamt0ICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmhhcygnZHBvcCcpKSB7XG4gICAgICAgIGF3YWl0IHZhbGlkYXRlRFBvUChhcywgcmVxdWVzdCwgY2xhaW1zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYWltcztcbn1cbiJdLCJuYW1lcyI6WyJVU0VSX0FHRU5UIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwic3RhcnRzV2l0aCIsIk5BTUUiLCJWRVJTSU9OIiwibG9vc2VJbnN0YW5jZU9mIiwiaW5wdXQiLCJleHBlY3RlZCIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJwcm90b3R5cGUiLCJjbG9ja1NrZXciLCJjbG9ja1RvbGVyYW5jZSIsImV4cGVyaW1lbnRhbF9jdXN0b21GZXRjaCIsImV4cGVyaW1lbnRhbEN1c3RvbUZldGNoIiwiZXhwZXJpbWVudGFsX3VzZU10bHNBbGlhcyIsImV4cGVyaW1lbnRhbFVzZU10bHNBbGlhcyIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImJ1ZiIsImVuY29kZSIsImRlY29kZSIsIkNIVU5LX1NJWkUiLCJlbmNvZGVCYXNlNjRVcmwiLCJBcnJheUJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJhcnIiLCJpIiwiYnl0ZUxlbmd0aCIsInB1c2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInN1YmFycmF5IiwiYnRvYSIsImpvaW4iLCJyZXBsYWNlIiwiZGVjb2RlQmFzZTY0VXJsIiwiYmluYXJ5IiwiYXRvYiIsImJ5dGVzIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImNhdXNlIiwiT1BFIiwiYjY0dSIsIkxSVSIsImNvbnN0cnVjdG9yIiwibWF4U2l6ZSIsImNhY2hlIiwiTWFwIiwiX2NhY2hlIiwiZ2V0Iiwia2V5IiwidiIsInVwZGF0ZSIsInVuZGVmaW5lZCIsImhhcyIsInNldCIsInZhbHVlIiwiZGVsZXRlIiwic2l6ZSIsIlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJuYW1lIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IiLCJvcHRpb25zIiwiZHBvcE5vbmNlcyIsImlzQ3J5cHRvS2V5IiwiQ3J5cHRvS2V5IiwiaXNQcml2YXRlS2V5IiwidHlwZSIsImlzUHVibGljS2V5IiwiU1VQUE9SVEVEX0pXU19BTEdTIiwicHJvY2Vzc0Rwb3BOb25jZSIsInJlc3BvbnNlIiwiaGVhZGVycyIsInVybCIsIlVSTCIsIm9yaWdpbiIsIm5vcm1hbGl6ZVR5cCIsInRvTG93ZXJDYXNlIiwiaXNKc29uT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwicHJlcGFyZUhlYWRlcnMiLCJIZWFkZXJzIiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiVHlwZUVycm9yIiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJkaXNjb3ZlcnlSZXF1ZXN0IiwiaXNzdWVySWRlbnRpZmllciIsInByb3RvY29sIiwiaHJlZiIsImFsZ29yaXRobSIsInBhdGhuYW1lIiwiZmV0Y2giLCJtZXRob2QiLCJyZWRpcmVjdCIsInRoZW4iLCJ2YWxpZGF0ZVN0cmluZyIsInByb2Nlc3NEaXNjb3ZlcnlSZXNwb25zZSIsImV4cGVjdGVkSXNzdWVySWRlbnRpZmllciIsIlJlc3BvbnNlIiwic3RhdHVzIiwiYXNzZXJ0UmVhZGFibGVSZXNwb25zZSIsImpzb24iLCJpc3N1ZXIiLCJyYW5kb21CeXRlcyIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsImdlbmVyYXRlUmFuZG9tQ29kZVZlcmlmaWVyIiwiZ2VuZXJhdGVSYW5kb21TdGF0ZSIsImdlbmVyYXRlUmFuZG9tTm9uY2UiLCJjYWxjdWxhdGVQS0NFQ29kZUNoYWxsZW5nZSIsImNvZGVWZXJpZmllciIsInN1YnRsZSIsImRpZ2VzdCIsImdldEtleUFuZEtpZCIsImtpZCIsImZvcm1VcmxFbmNvZGUiLCJ0b2tlbiIsImVuY29kZVVSSUNvbXBvbmVudCIsImNsaWVudFNlY3JldEJhc2ljIiwiY2xpZW50SWQiLCJjbGllbnRTZWNyZXQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiY3JlZGVudGlhbHMiLCJwc0FsZyIsImhhc2giLCJyc0FsZyIsImVzQWxnIiwibmFtZWRDdXJ2ZSIsImtleVRvSndzIiwiZ2V0Q2xvY2tTa2V3IiwiY2xpZW50IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJnZXRDbG9ja1RvbGVyYW5jZSIsInRvbGVyYW5jZSIsIk1hdGgiLCJzaWduIiwiZXBvY2hUaW1lIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiY2xpZW50QXNzZXJ0aW9uIiwiYXMiLCJqdGkiLCJhdWQiLCJ0b2tlbl9lbmRwb2ludCIsImV4cCIsImlhdCIsIm5iZiIsImlzcyIsImNsaWVudF9pZCIsInN1YiIsInByaXZhdGVLZXlKd3QiLCJqd3QiLCJhbGciLCJhc3NlcnRBcyIsImFzc2VydENsaWVudCIsImFzc2VydENsaWVudFNlY3JldCIsImFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleSIsImNsaWVudEF1dGhNZXRob2QiLCJjbGllbnRQcml2YXRlS2V5IiwiYXNzZXJ0Tm9DbGllbnRTZWNyZXQiLCJjbGllbnRBdXRoZW50aWNhdGlvbiIsImJvZHkiLCJ0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCIsImNsaWVudF9zZWNyZXQiLCJoZWFkZXIiLCJjbGFpbXNTZXQiLCJ1c2FnZXMiLCJpbmNsdWRlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzaWduYXR1cmUiLCJrZXlUb1N1YnRsZSIsImlzc3VlUmVxdWVzdE9iamVjdCIsInBhcmFtZXRlcnMiLCJwcml2YXRlS2V5IiwiVVJMU2VhcmNoUGFyYW1zIiwiY2xhaW1zIiwicmVzb3VyY2UiLCJnZXRBbGwiLCJwYXJzZSIsInR5cCIsImRwb3BQcm9vZkp3dCIsImh0bSIsImFjY2Vzc1Rva2VuIiwicHVibGljS2V5Iiwibm9uY2UiLCJleHRyYWN0YWJsZSIsInByb29mIiwiandrIiwicHVibGljSndrIiwiaHR1IiwiYXRoIiwiandrQ2FjaGUiLCJXZWFrTWFwIiwia3R5IiwiZSIsIm4iLCJ4IiwieSIsImNydiIsImV4cG9ydEtleSIsInZhbGlkYXRlRW5kcG9pbnQiLCJlbmRwb2ludCIsInJlc29sdmVFbmRwb2ludCIsIm10bHNfZW5kcG9pbnRfYWxpYXNlcyIsInB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0IiwiRFBvUCIsImF1dGhlbnRpY2F0ZWRSZXF1ZXN0IiwiaXNPQXV0aDJFcnJvciIsImVycm9yIiwidW5xdW90ZSIsInNsaWNlIiwiU1BMSVRfUkVHRVhQIiwiU0NIRU1FU19SRUdFWFAiLCJ3d3dBdXRoIiwic2NoZW1lIiwicGFyYW1zIiwic3BsaXQiLCJpZHgiLCJwYXJzZVd3d0F1dGhlbnRpY2F0ZUNoYWxsZW5nZXMiLCJyZXN1bHQiLCJpbmRleCIsIm1hdGNoQWxsIiwiY2hhbGxlbmdlcyIsIm1hcCIsImluZGV4T2YiLCJvdGhlcnMiLCJuZXh0IiwicHJvY2Vzc1B1c2hlZEF1dGhvcml6YXRpb25SZXNwb25zZSIsImVyciIsImhhbmRsZU9BdXRoQm9keUVycm9yIiwicmVxdWVzdF91cmkiLCJleHBpcmVzX2luIiwicHJvdGVjdGVkUmVzb3VyY2VSZXF1ZXN0IiwidXNlckluZm9SZXF1ZXN0IiwidXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImFwcGVuZCIsImp3a3NDYWNoZSIsImdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpIiwiY2hlY2tTdXBwb3J0ZWRKd3NBbGciLCJqd2tzIiwiYWdlIiwiandrc1JlcXVlc3QiLCJwcm9jZXNzSndrc1Jlc3BvbnNlIiwiY2FuZGlkYXRlcyIsImtleXMiLCJmaWx0ZXIiLCJ1c2UiLCJrZXlfb3BzIiwiaW1wb3J0SndrIiwic2tpcFN1YmplY3RDaGVjayIsImdldENvbnRlbnRUeXBlIiwicHJvY2Vzc1VzZXJJbmZvUmVzcG9uc2UiLCJleHBlY3RlZFN1YmplY3QiLCJ2YWxpZGF0ZUp3dCIsInRleHQiLCJjaGVja1NpZ25pbmdBbGdvcml0aG0iLCJiaW5kIiwidXNlcmluZm9fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsIm5vU2lnbmF0dXJlQ2hlY2siLCJ2YWxpZGF0ZU9wdGlvbmFsQXVkaWVuY2UiLCJ2YWxpZGF0ZU9wdGlvbmFsSXNzdWVyIiwidG9rZW5FbmRwb2ludFJlcXVlc3QiLCJncmFudFR5cGUiLCJyZWZyZXNoVG9rZW5HcmFudFJlcXVlc3QiLCJyZWZyZXNoVG9rZW4iLCJhZGRpdGlvbmFsUGFyYW1ldGVycyIsImlkVG9rZW5DbGFpbXMiLCJnZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zIiwicmVmIiwiaWRfdG9rZW4iLCJwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UiLCJpZ25vcmVJZFRva2VuIiwiaWdub3JlUmVmcmVzaFRva2VuIiwiYWNjZXNzX3Rva2VuIiwidG9rZW5fdHlwZSIsInJlZnJlc2hfdG9rZW4iLCJzY29wZSIsImlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGciLCJpZF90b2tlbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwidmFsaWRhdGVQcmVzZW5jZSIsInZhbGlkYXRlSXNzdWVyIiwidmFsaWRhdGVBdWRpZW5jZSIsImF6cCIsInJlcXVpcmVfYXV0aF90aW1lIiwiYXV0aF90aW1lIiwicHJvY2Vzc1JlZnJlc2hUb2tlblJlc3BvbnNlIiwiYnJhbmRlZCIsIldlYWtTZXQiLCJicmFuZCIsInNlYXJjaFBhcmFtcyIsImFkZCIsImF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0IiwiY2FsbGJhY2tQYXJhbWV0ZXJzIiwicmVkaXJlY3RVcmkiLCJjb2RlIiwiZ2V0VVJMU2VhcmNoUGFyYW1ldGVyIiwiand0Q2xhaW1OYW1lcyIsImNfaGFzaCIsInNfaGFzaCIsImNuZiIsInJlcXVpcmVkIiwiY2xhaW0iLCJleHBlY3ROb05vbmNlIiwic2tpcEF1dGhUaW1lQ2hlY2siLCJwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZSIsImV4cGVjdGVkTm9uY2UiLCJtYXhBZ2UiLCJkZWZhdWx0X21heF9hZ2UiLCJwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPQXV0aDJSZXNwb25zZSIsImNoZWNrSnd0VHlwZSIsImNsaWVudENyZWRlbnRpYWxzR3JhbnRSZXF1ZXN0IiwicHJvY2Vzc0NsaWVudENyZWRlbnRpYWxzUmVzcG9uc2UiLCJyZXZvY2F0aW9uUmVxdWVzdCIsInByb2Nlc3NSZXZvY2F0aW9uUmVzcG9uc2UiLCJib2R5VXNlZCIsImludHJvc3BlY3Rpb25SZXF1ZXN0IiwicmVxdWVzdEp3dFJlc3BvbnNlIiwiaW50cm9zcGVjdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwicHJvY2Vzc0ludHJvc3BlY3Rpb25SZXNwb25zZSIsImludHJvc3BlY3Rpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsInRva2VuX2ludHJvc3BlY3Rpb24iLCJhY3RpdmUiLCJldmVyeSIsImNhbGwiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yX3VyaSIsImFsZ3MiLCJjaGVja1JzYUtleUFsZ29yaXRobSIsIm1vZHVsdXNMZW5ndGgiLCJlY2RzYUhhc2hOYW1lIiwic2FsdExlbmd0aCIsInBhcnNlSW50IiwiandzIiwiY2hlY2tBbGciLCJnZXRLZXkiLCJwcm90ZWN0ZWRIZWFkZXIiLCJwYXlsb2FkIiwiZW5jb2RlZFNpZ25hdHVyZSIsImNyaXQiLCJ2ZXJpZmllZCIsInZlcmlmeSIsInZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlIiwiZXhwZWN0ZWRTdGF0ZSIsImp3a3NfdXJpIiwiYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiYXV0aG9yaXphdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwidmFsaWRhdGVBdXRoUmVzcG9uc2UiLCJpZFRva2VuSGFzaCIsImRhdGEiLCJpZFRva2VuSGFzaE1hdGNoZXMiLCJhY3R1YWwiLCJleHBlcmltZW50YWxfdmFsaWRhdGVEZXRhY2hlZFNpZ25hdHVyZVJlc3BvbnNlIiwiZXhwZWN0Tm9TdGF0ZSIsImF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJyZXF1aXJlZENsYWltcyIsInNraXBTdGF0ZUNoZWNrIiwic3RhdGUiLCJhbGdUb1N1YnRsZSIsImV4dCIsImltcG9ydEtleSIsImRldmljZUF1dGhvcml6YXRpb25SZXF1ZXN0IiwicHJvY2Vzc0RldmljZUF1dGhvcml6YXRpb25SZXNwb25zZSIsImRldmljZV9jb2RlIiwidXNlcl9jb2RlIiwidmVyaWZpY2F0aW9uX3VyaSIsInZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUiLCJpbnRlcnZhbCIsImRldmljZUNvZGVHcmFudFJlcXVlc3QiLCJkZXZpY2VDb2RlIiwicHJvY2Vzc0RldmljZUNvZGVSZXNwb25zZSIsImdlbmVyYXRlS2V5UGFpciIsImFzc2lnbiIsInB1YmxpY0V4cG9uZW50IiwiZ2VuZXJhdGVLZXkiLCJub3JtYWxpemVIdHUiLCJzZWFyY2giLCJ2YWxpZGF0ZURQb1AiLCJyZXF1ZXN0IiwiYWNjZXNzVG9rZW5DbGFpbXMiLCJqa3QiLCJkcG9wX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJkaWZmIiwiYWJzIiwiY29tcG9uZW50cyIsImV4cGVyaW1lbnRhbF92YWxpZGF0ZUp3dEFjY2Vzc1Rva2VuIiwiZXhwZWN0ZWRBdWRpZW5jZSIsIlJlcXVlc3QiLCJhdXRob3JpemF0aW9uIiwicmVxdWlyZURQb1AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/oauth4webapi/build/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/oauth4webapi/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/oauth4webapi/build/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OperationProcessingError: () => (/* binding */ OperationProcessingError),\n/* harmony export */   UnsupportedOperationError: () => (/* binding */ UnsupportedOperationError),\n/* harmony export */   authorizationCodeGrantRequest: () => (/* binding */ authorizationCodeGrantRequest),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   clientCredentialsGrantRequest: () => (/* binding */ clientCredentialsGrantRequest),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   deviceAuthorizationRequest: () => (/* binding */ deviceAuthorizationRequest),\n/* harmony export */   deviceCodeGrantRequest: () => (/* binding */ deviceCodeGrantRequest),\n/* harmony export */   discoveryRequest: () => (/* binding */ discoveryRequest),\n/* harmony export */   expectNoNonce: () => (/* binding */ expectNoNonce),\n/* harmony export */   expectNoState: () => (/* binding */ expectNoState),\n/* harmony export */   experimentalCustomFetch: () => (/* binding */ experimentalCustomFetch),\n/* harmony export */   experimentalUseMtlsAlias: () => (/* binding */ experimentalUseMtlsAlias),\n/* harmony export */   experimental_customFetch: () => (/* binding */ experimental_customFetch),\n/* harmony export */   experimental_useMtlsAlias: () => (/* binding */ experimental_useMtlsAlias),\n/* harmony export */   experimental_validateDetachedSignatureResponse: () => (/* binding */ experimental_validateDetachedSignatureResponse),\n/* harmony export */   experimental_validateJwtAccessToken: () => (/* binding */ experimental_validateJwtAccessToken),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateRandomCodeVerifier: () => (/* binding */ generateRandomCodeVerifier),\n/* harmony export */   generateRandomNonce: () => (/* binding */ generateRandomNonce),\n/* harmony export */   generateRandomState: () => (/* binding */ generateRandomState),\n/* harmony export */   getValidatedIdTokenClaims: () => (/* binding */ getValidatedIdTokenClaims),\n/* harmony export */   introspectionRequest: () => (/* binding */ introspectionRequest),\n/* harmony export */   isOAuth2Error: () => (/* binding */ isOAuth2Error),\n/* harmony export */   issueRequestObject: () => (/* binding */ issueRequestObject),\n/* harmony export */   parseWwwAuthenticateChallenges: () => (/* binding */ parseWwwAuthenticateChallenges),\n/* harmony export */   processAuthorizationCodeOAuth2Response: () => (/* binding */ processAuthorizationCodeOAuth2Response),\n/* harmony export */   processAuthorizationCodeOpenIDResponse: () => (/* binding */ processAuthorizationCodeOpenIDResponse),\n/* harmony export */   processClientCredentialsResponse: () => (/* binding */ processClientCredentialsResponse),\n/* harmony export */   processDeviceAuthorizationResponse: () => (/* binding */ processDeviceAuthorizationResponse),\n/* harmony export */   processDeviceCodeResponse: () => (/* binding */ processDeviceCodeResponse),\n/* harmony export */   processDiscoveryResponse: () => (/* binding */ processDiscoveryResponse),\n/* harmony export */   processIntrospectionResponse: () => (/* binding */ processIntrospectionResponse),\n/* harmony export */   processPushedAuthorizationResponse: () => (/* binding */ processPushedAuthorizationResponse),\n/* harmony export */   processRefreshTokenResponse: () => (/* binding */ processRefreshTokenResponse),\n/* harmony export */   processRevocationResponse: () => (/* binding */ processRevocationResponse),\n/* harmony export */   processUserInfoResponse: () => (/* binding */ processUserInfoResponse),\n/* harmony export */   protectedResourceRequest: () => (/* binding */ protectedResourceRequest),\n/* harmony export */   pushedAuthorizationRequest: () => (/* binding */ pushedAuthorizationRequest),\n/* harmony export */   refreshTokenGrantRequest: () => (/* binding */ refreshTokenGrantRequest),\n/* harmony export */   revocationRequest: () => (/* binding */ revocationRequest),\n/* harmony export */   skipAuthTimeCheck: () => (/* binding */ skipAuthTimeCheck),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   userInfoRequest: () => (/* binding */ userInfoRequest),\n/* harmony export */   validateAuthResponse: () => (/* binding */ validateAuthResponse),\n/* harmony export */   validateJwtAuthResponse: () => (/* binding */ validateJwtAuthResponse)\n/* harmony export */ });\nlet USER_AGENT;\nif (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n    const NAME = \"oauth4webapi\";\n    const VERSION = \"v2.8.1\";\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n    if (input == null) {\n        return false;\n    }\n    try {\n        return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];\n    } catch  {\n        return false;\n    }\n}\nconst clockSkew = Symbol();\nconst clockTolerance = Symbol();\nconst experimental_customFetch = Symbol();\nconst experimentalCustomFetch = experimental_customFetch;\nconst experimental_useMtlsAlias = Symbol();\nconst experimentalUseMtlsAlias = experimental_useMtlsAlias;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === \"string\") {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n    if (input instanceof ArrayBuffer) {\n        input = new Uint8Array(input);\n    }\n    const arr = [];\n    for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction decodeBase64Url(input) {\n    try {\n        const binary = atob(input.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n        const bytes = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++){\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    } catch (cause) {\n        throw new OPE(\"The input to be decoded is not correctly encoded.\", {\n            cause\n        });\n    }\n}\nfunction b64u(input) {\n    if (typeof input === \"string\") {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass LRU {\n    constructor(maxSize){\n        this.cache = new Map();\n        this._cache = new Map();\n        this.maxSize = maxSize;\n    }\n    get(key) {\n        let v = this.cache.get(key);\n        if (v) {\n            return v;\n        }\n        if (v = this._cache.get(key)) {\n            this.update(key, v);\n            return v;\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n    }\n    set(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.set(key, value);\n        } else {\n            this.update(key, value);\n        }\n        return this;\n    }\n    delete(key) {\n        if (this.cache.has(key)) {\n            return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n            return this._cache.delete(key);\n        }\n        return false;\n    }\n    update(key, value) {\n        this.cache.set(key, value);\n        if (this.cache.size >= this.maxSize) {\n            this._cache = this.cache;\n            this.cache = new Map();\n        }\n    }\n}\nclass UnsupportedOperationError extends Error {\n    constructor(message){\n        super(message ?? \"operation not supported\");\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass OperationProcessingError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n    return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n    return isCryptoKey(key) && key.type === \"private\";\n}\nfunction isPublicKey(key) {\n    return isCryptoKey(key) && key.type === \"public\";\n}\nconst SUPPORTED_JWS_ALGS = [\n    \"PS256\",\n    \"ES256\",\n    \"RS256\",\n    \"PS384\",\n    \"ES384\",\n    \"RS384\",\n    \"PS512\",\n    \"ES512\",\n    \"RS512\",\n    \"EdDSA\"\n];\nfunction processDpopNonce(response) {\n    try {\n        if (response.headers.has(\"dpop-nonce\")) {\n            const url = new URL(response.url);\n            dpopNonces.set(url.origin, response.headers.get(\"dpop-nonce\"));\n        }\n    } finally{\n        return response;\n    }\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, \"\");\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== \"object\" || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (looseInstanceOf(input, Headers)) {\n        input = Object.fromEntries(input.entries());\n    }\n    const headers = new Headers(input);\n    if (USER_AGENT && !headers.has(\"user-agent\")) {\n        headers.set(\"user-agent\", USER_AGENT);\n    }\n    if (headers.has(\"authorization\")) {\n        throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n    }\n    if (headers.has(\"dpop\")) {\n        throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n    }\n    return headers;\n}\nfunction signal(value) {\n    if (typeof value === \"function\") {\n        value = value();\n    }\n    if (!(value instanceof AbortSignal)) {\n        throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n    }\n    return value;\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n    if (!(issuerIdentifier instanceof URL)) {\n        throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n    }\n    if (issuerIdentifier.protocol !== \"https:\" && issuerIdentifier.protocol !== \"http:\") {\n        throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n    }\n    const url = new URL(issuerIdentifier.href);\n    switch(options?.algorithm){\n        case undefined:\n        case \"oidc\":\n            url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace(\"//\", \"/\");\n            break;\n        case \"oauth2\":\n            if (url.pathname === \"/\") {\n                url.pathname = `.well-known/oauth-authorization-server`;\n            } else {\n                url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace(\"//\", \"/\");\n            }\n            break;\n        default:\n            throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n    }\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nfunction validateString(input) {\n    return typeof input === \"string\" && input.length !== 0;\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    if (!(expectedIssuerIdentifier instanceof URL)) {\n        throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.issuer)) {\n        throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n    }\n    if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n        throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n    }\n    return json;\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n    return randomBytes();\n}\nfunction generateRandomState() {\n    return randomBytes();\n}\nfunction generateRandomNonce() {\n    return randomBytes();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return {\n            key: input\n        };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined && !validateString(input.kid)) {\n        throw new TypeError('\"kid\" must be a non-empty string');\n    }\n    return {\n        key: input.key,\n        kid: input.kid\n    };\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/%20/g, \"+\");\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n    const username = formUrlEncode(clientId);\n    const password = formUrlEncode(clientSecret);\n    const credentials = btoa(`${username}:${password}`);\n    return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"PS256\";\n        case \"SHA-384\":\n            return \"PS384\";\n        case \"SHA-512\":\n            return \"PS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction rsAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"RS256\";\n        case \"SHA-384\":\n            return \"RS384\";\n        case \"SHA-512\":\n            return \"RS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction esAlg(key) {\n    switch(key.algorithm.namedCurve){\n        case \"P-256\":\n            return \"ES256\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-521\":\n            return \"ES512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\");\n    }\n}\nfunction keyToJws(key) {\n    switch(key.algorithm.name){\n        case \"RSA-PSS\":\n            return psAlg(key);\n        case \"RSASSA-PKCS1-v1_5\":\n            return rsAlg(key);\n        case \"ECDSA\":\n            return esAlg(key);\n        case \"Ed25519\":\n        case \"Ed448\":\n            return \"EdDSA\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\");\n    }\n}\nfunction getClockSkew(client) {\n    if (client && clockSkew in client) {\n        if (Number.isFinite(client[clockSkew])) {\n            return client[clockSkew];\n        }\n    }\n    return 0;\n}\nfunction getClockTolerance(client) {\n    if (client && clockTolerance in client) {\n        const tolerance = client[clockTolerance];\n        if (Number.isFinite(tolerance) && Math.sign(tolerance) !== -1) {\n            return tolerance;\n        }\n    }\n    return 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: [\n            as.issuer,\n            as.token_endpoint\n        ],\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id\n    };\n}\nasync function privateKeyJwt(as, client, key, kid) {\n    return jwt({\n        alg: keyToJws(key),\n        kid\n    }, clientAssertion(as, client), key);\n}\nfunction assertAs(as) {\n    if (typeof as !== \"object\" || as === null) {\n        throw new TypeError('\"as\" must be an object');\n    }\n    if (!validateString(as.issuer)) {\n        throw new TypeError('\"as.issuer\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClient(client) {\n    if (typeof client !== \"object\" || client === null) {\n        throw new TypeError('\"client\" must be an object');\n    }\n    if (!validateString(client.client_id)) {\n        throw new TypeError('\"client.client_id\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClientSecret(clientSecret) {\n    if (!validateString(clientSecret)) {\n        throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n    }\n    return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n    if (clientPrivateKey !== undefined) {\n        throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n    if (clientSecret !== undefined) {\n        throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n    body.delete(\"client_secret\");\n    body.delete(\"client_assertion_type\");\n    body.delete(\"client_assertion\");\n    switch(client.token_endpoint_auth_method){\n        case undefined:\n        case \"client_secret_basic\":\n            {\n                assertNoClientPrivateKey(\"client_secret_basic\", clientPrivateKey);\n                headers.set(\"authorization\", clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n                break;\n            }\n        case \"client_secret_post\":\n            {\n                assertNoClientPrivateKey(\"client_secret_post\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_secret\", assertClientSecret(client.client_secret));\n                break;\n            }\n        case \"private_key_jwt\":\n            {\n                assertNoClientSecret(\"private_key_jwt\", client.client_secret);\n                if (clientPrivateKey === undefined) {\n                    throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n                }\n                const { key, kid } = getKeyAndKid(clientPrivateKey);\n                if (!isPrivateKey(key)) {\n                    throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n                }\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                body.set(\"client_assertion\", await privateKeyJwt(as, client, key, kid));\n                break;\n            }\n        case \"tls_client_auth\":\n        case \"self_signed_tls_client_auth\":\n        case \"none\":\n            {\n                assertNoClientSecret(client.token_endpoint_auth_method, client.client_secret);\n                assertNoClientPrivateKey(client.token_endpoint_auth_method, clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                break;\n            }\n        default:\n            throw new UnsupportedOperationError(\"unsupported client token_endpoint_auth_method\");\n    }\n}\nasync function jwt(header, claimsSet, key) {\n    if (!key.usages.includes(\"sign\")) {\n        throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(claimsSet)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nasync function issueRequestObject(as, client, parameters, privateKey) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    if (!isPrivateKey(key)) {\n        throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n    }\n    parameters.set(\"client_id\", client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id\n    };\n    let resource;\n    if (parameters.has(\"resource\") && (resource = parameters.getAll(\"resource\")) && resource.length > 1) {\n        claims.resource = resource;\n    }\n    if (parameters.has(\"claims\")) {\n        const value = parameters.get(\"claims\");\n        if (value === \"[object Object]\") {\n            throw new OPE('\"claims\" parameter must be passed as a UTF-8 encoded JSON');\n        }\n        try {\n            claims.claims = JSON.parse(value);\n        } catch (cause) {\n            throw new OPE('failed to parse the \"claims\" parameter as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(claims.claims)) {\n            throw new OPE('\"claims\" parameter must be a top level object');\n        }\n    }\n    return jwt({\n        alg: keyToJws(key),\n        typ: \"oauth-authz-req+jwt\",\n        kid\n    }, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n    const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n    if (!isPrivateKey(privateKey)) {\n        throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n    }\n    if (!isPublicKey(publicKey)) {\n        throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n    }\n    if (nonce !== undefined && !validateString(nonce)) {\n        throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n    }\n    if (!publicKey.extractable) {\n        throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n    }\n    const now = epochTime() + clockSkew;\n    const proof = await jwt({\n        alg: keyToJws(privateKey),\n        typ: \"dpop+jwt\",\n        jwk: await publicJwk(publicKey)\n    }, {\n        iat: now,\n        jti: randomBytes(),\n        htm,\n        nonce,\n        htu: `${url.origin}${url.pathname}`,\n        ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : undefined\n    }, privateKey);\n    headers.set(\"dpop\", proof);\n}\nlet jwkCache;\nasync function publicJwk(key) {\n    jwkCache || (jwkCache = new WeakMap());\n    if (jwkCache.has(key)) {\n        return jwkCache.get(key);\n    }\n    const { kty, e, n, x, y, crv } = await crypto.subtle.exportKey(\"jwk\", key);\n    const jwk = {\n        kty,\n        e,\n        n,\n        x,\n        y,\n        crv\n    };\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nfunction validateEndpoint(value, endpoint, options) {\n    if (typeof value !== \"string\") {\n        if (options?.[experimental_useMtlsAlias]) {\n            throw new TypeError(`\"as.mtls_endpoint_aliases.${endpoint}\" must be a string`);\n        } else {\n            throw new TypeError(`\"as.${endpoint}\" must be a string`);\n        }\n    }\n    return new URL(value);\n}\nfunction resolveEndpoint(as, endpoint, options) {\n    if (options?.[experimental_useMtlsAlias] && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, options);\n    }\n    return validateEndpoint(as[endpoint], endpoint);\n}\nasync function pushedAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"pushed_authorization_request_endpoint\", options);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nfunction isOAuth2Error(input) {\n    const value = input;\n    if (typeof value !== \"object\" || Array.isArray(value) || value === null) {\n        return false;\n    }\n    return value.error !== undefined;\n}\nfunction unquote(value) {\n    if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n        return value.slice(1, -1);\n    }\n    return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n    const arr = params.split(SPLIT_REGEXP).slice(1);\n    if (!arr.length) {\n        return {\n            scheme: scheme.toLowerCase(),\n            parameters: {}\n        };\n    }\n    arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, \"\");\n    const parameters = {};\n    for(let i = 1; i < arr.length; i += 2){\n        const idx = i;\n        if (arr[idx][0] === '\"') {\n            while(arr[idx].slice(-1) !== '\"' && ++i < arr.length){\n                arr[idx] += arr[i];\n            }\n        }\n        const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, \"\").toLowerCase();\n        parameters[key] = unquote(arr[idx]);\n    }\n    return {\n        scheme: scheme.toLowerCase(),\n        parameters\n    };\n}\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (!response.headers.has(\"www-authenticate\")) {\n        return undefined;\n    }\n    const header = response.headers.get(\"www-authenticate\");\n    const result = [];\n    for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)){\n        result.push([\n            scheme,\n            index\n        ]);\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    const challenges = result.map(([scheme, indexOf], i, others)=>{\n        const next = others[i + 1];\n        let parameters;\n        if (next) {\n            parameters = header.slice(indexOf, next[1]);\n        } else {\n            parameters = header.slice(indexOf);\n        }\n        return wwwAuth(scheme, parameters);\n    });\n    return challenges;\n}\nasync function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 201) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.request_uri)) {\n        throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    return json;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    if (!validateString(accessToken)) {\n        throw new TypeError('\"accessToken\" must be a non-empty string');\n    }\n    if (!(url instanceof URL)) {\n        throw new TypeError('\"url\" must be an instance of URL');\n    }\n    headers = prepareHeaders(headers);\n    if (options?.DPoP === undefined) {\n        headers.set(\"authorization\", `Bearer ${accessToken}`);\n    } else {\n        await dpopProofJwt(headers, options.DPoP, url, \"GET\", getClockSkew({\n            [clockSkew]: options?.[clockSkew]\n        }), accessToken);\n        headers.set(\"authorization\", `DPoP ${accessToken}`);\n    }\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"userinfo_endpoint\", options);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set(\"accept\", \"application/jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n        headers.append(\"accept\", \"application/jwt\");\n    }\n    return protectedResourceRequest(accessToken, \"GET\", url, headers, null, {\n        ...options,\n        [clockSkew]: getClockSkew(client)\n    });\n}\nlet jwksCache;\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(alg);\n    let jwks;\n    let age;\n    jwksCache || (jwksCache = new WeakMap());\n    if (jwksCache.has(as)) {\n        ;\n        ({ jwks, age } = jwksCache.get(as));\n        if (age >= 300) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    } else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        jwksCache.set(as, {\n            jwks,\n            iat: epochTime(),\n            get age () {\n                return epochTime() - this.iat;\n            }\n        });\n    }\n    let kty;\n    switch(alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            kty = \"RSA\";\n            break;\n        case \"ES\":\n            kty = \"EC\";\n            break;\n        case \"Ed\":\n            kty = \"OKP\";\n            break;\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const candidates = jwks.keys.filter((jwk)=>{\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== \"sig\") {\n            return false;\n        }\n        if (jwk.key_ops?.includes(\"verify\") === false) {\n            return false;\n        }\n        switch(true){\n            case alg === \"ES256\" && jwk.crv !== \"P-256\":\n            case alg === \"ES384\" && jwk.crv !== \"P-384\":\n            case alg === \"ES512\" && jwk.crv !== \"P-521\":\n            case alg === \"EdDSA\" && !(jwk.crv === \"Ed25519\" || jwk.crv === \"Ed448\"):\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw new OPE(\"error when selecting a JWT verification key, no applicable keys found\");\n    } else if (length !== 1) {\n        throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== \"public\") {\n        throw new OPE(\"jwks_uri must only contain public keys\");\n    }\n    return key;\n}\nconst skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n    return response.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as, client, expectedSubject, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as.issuer));\n        json = claims;\n    } else {\n        if (client.userinfo_signed_response_alg) {\n            throw new OPE(\"JWT UserInfo Response expected\");\n        }\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.sub)) {\n        throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n    }\n    switch(expectedSubject){\n        case skipSubjectCheck:\n            break;\n        default:\n            if (!validateString(expectedSubject)) {\n                throw new OPE('\"expectedSubject\" must be a non-empty string');\n            }\n            if (json.sub !== expectedSubject) {\n                throw new OPE('unexpected \"response\" body \"sub\" value');\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n    headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n    const url = resolveEndpoint(as, \"token_endpoint\", options);\n    parameters.set(\"grant_type\", grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, parameters, headers, options);\n}\nasync function refreshTokenGrantRequest(as, client, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(refreshToken)) {\n        throw new TypeError('\"refreshToken\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"refresh_token\", refreshToken);\n    return tokenEndpointRequest(as, client, \"refresh_token\", parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nfunction getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n    }\n    return claims;\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Token Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.access_token)) {\n        throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n    }\n    if (!validateString(json.token_type)) {\n        throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n    }\n    json.token_type = json.token_type.toLowerCase();\n    if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n        throw new UnsupportedOperationError(\"unsupported `token_type` value\");\n    }\n    if (json.expires_in !== undefined && (typeof json.expires_in !== \"number\" || json.expires_in <= 0)) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (!ignoreRefreshToken && json.refresh_token !== undefined && !validateString(json.refresh_token)) {\n        throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n    }\n    if (json.scope !== undefined && typeof json.scope !== \"string\") {\n        throw new OPE('\"response\" body \"scope\" property must be a string');\n    }\n    if (!ignoreIdToken) {\n        if (json.id_token !== undefined && !validateString(json.id_token)) {\n            throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n        }\n        if (json.id_token) {\n            const { claims } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n                \"aud\",\n                \"exp\",\n                \"iat\",\n                \"iss\",\n                \"sub\"\n            ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n            if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n                throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n            }\n            if (client.require_auth_time && typeof claims.auth_time !== \"number\") {\n                throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n            }\n            idTokenClaims.set(json, claims);\n        }\n    }\n    return json;\n}\nasync function processRefreshTokenResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n        }\n    } else if (result.claims.aud !== expected) {\n        throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n    return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(expected, result);\n    }\n    return result;\n}\nfunction validateIssuer(expected, result) {\n    if (result.claims.iss !== expected) {\n        throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nasync function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n    }\n    if (!validateString(redirectUri)) {\n        throw new TypeError('\"redirectUri\" must be a non-empty string');\n    }\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    const code = getURLSearchParameter(callbackParameters, \"code\");\n    if (!code) {\n        throw new OPE('no authorization code in \"callbackParameters\"');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"redirect_uri\", redirectUri);\n    parameters.set(\"code_verifier\", codeVerifier);\n    parameters.set(\"code\", code);\n    return tokenEndpointRequest(as, client, \"authorization_code\", parameters, options);\n}\nconst jwtClaimNames = {\n    aud: \"audience\",\n    c_hash: \"code hash\",\n    client_id: \"client id\",\n    exp: \"expiration time\",\n    iat: \"issued at\",\n    iss: \"issuer\",\n    jti: \"jwt id\",\n    nonce: \"nonce\",\n    s_hash: \"state hash\",\n    sub: \"subject\",\n    ath: \"access token hash\",\n    htm: \"http method\",\n    htu: \"http uri\",\n    cnf: \"confirmation\"\n};\nfunction validatePresence(required, result) {\n    for (const claim of required){\n        if (result.claims[claim] === undefined) {\n            throw new OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`);\n        }\n    }\n    return result;\n}\nconst expectNoNonce = Symbol();\nconst skipAuthTimeCheck = Symbol();\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n    const result = await processGenericAccessTokenResponse(as, client, response);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!validateString(result.id_token)) {\n        throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    const claims = getValidatedIdTokenClaims(result);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    switch(expectedNonce){\n        case undefined:\n        case expectNoNonce:\n            if (claims.nonce !== undefined) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n            break;\n        default:\n            if (!validateString(expectedNonce)) {\n                throw new TypeError('\"expectedNonce\" must be a non-empty string');\n            }\n            if (claims.nonce === undefined) {\n                throw new OPE('ID Token \"nonce\" claim missing');\n            }\n            if (claims.nonce !== expectedNonce) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (result.id_token !== undefined) {\n        if (typeof result.id_token === \"string\" && result.id_token.length) {\n            throw new OPE(\"Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing\");\n        }\n        delete result.id_token;\n    }\n    return result;\n}\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== \"string\" || normalizeTyp(result.header.typ) !== expected) {\n        throw new OPE('unexpected JWT \"typ\" header parameter value');\n    }\n    return result;\n}\nasync function clientCredentialsGrantRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, \"client_credentials\", new URLSearchParams(parameters), options);\n}\nasync function processClientCredentialsResponse(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    return result;\n}\nasync function revocationRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, \"revocation_endpoint\", options);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete(\"accept\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processRevocationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n    }\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw new TypeError('\"response\" body has been used already');\n    }\n}\nasync function introspectionRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, \"introspection_endpoint\", options);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set(\"accept\", \"application/token-introspection+jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processIntrospectionResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/token-introspection+jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(checkJwtType.bind(undefined, \"token-introspection+jwt\")).then(validatePresence.bind(undefined, [\n            \"aud\",\n            \"iat\",\n            \"iss\"\n        ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n        json = claims.token_introspection;\n        if (!isJsonObject(json)) {\n            throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n        }\n    } else {\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(json)) {\n            throw new OPE('\"response\" body must be a top level object');\n        }\n    }\n    if (typeof json.active !== \"boolean\") {\n        throw new OPE('\"response\" body \"active\" property must be a boolean');\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, \"jwks_uri\");\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwk-set+json\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!Array.isArray(json.keys)) {\n        throw new OPE('\"response\" body \"keys\" property must be an array');\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n    }\n    return json;\n}\nasync function handleOAuthBodyError(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        try {\n            const json = await response.json();\n            if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n                if (json.error_description !== undefined && typeof json.error_description !== \"string\") {\n                    delete json.error_description;\n                }\n                if (json.error_uri !== undefined && typeof json.error_uri !== \"string\") {\n                    delete json.error_uri;\n                }\n                if (json.algs !== undefined && typeof json.algs !== \"string\") {\n                    delete json.algs;\n                }\n                if (json.scope !== undefined && typeof json.scope !== \"string\") {\n                    delete json.scope;\n                }\n                return json;\n            }\n        } catch  {}\n    }\n    return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n    if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n    }\n    return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n    if (typeof algorithm.modulusLength !== \"number\" || algorithm.modulusLength < 2048) {\n        throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n    }\n}\nfunction ecdsaHashName(namedCurve) {\n    switch(namedCurve){\n        case \"P-256\":\n            return \"SHA-256\";\n        case \"P-384\":\n            return \"SHA-384\";\n        case \"P-521\":\n            return \"SHA-512\";\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nfunction keyToSubtle(key) {\n    switch(key.algorithm.name){\n        case \"ECDSA\":\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key.algorithm.namedCurve)\n            };\n        case \"RSA-PSS\":\n            {\n                checkRsaKeyAlgorithm(key.algorithm);\n                switch(key.algorithm.hash.name){\n                    case \"SHA-256\":\n                    case \"SHA-384\":\n                    case \"SHA-512\":\n                        return {\n                            name: key.algorithm.name,\n                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n                        };\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            checkRsaKeyAlgorithm(key.algorithm);\n            return key.algorithm.name;\n        case \"Ed448\":\n        case \"Ed25519\":\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance) {\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(\".\");\n    if (length === 5) {\n        throw new UnsupportedOperationError(\"JWE structure JWTs are not supported\");\n    }\n    if (length !== 3) {\n        throw new OPE(\"Invalid JWT\");\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Header body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(header)) {\n        throw new OPE(\"JWT Header must be a top level object\");\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new OPE('unexpected JWT \"crit\" header parameter');\n    }\n    const signature = b64u(encodedSignature);\n    let key;\n    if (getKey !== noSignatureCheck) {\n        key = await getKey(header);\n        const input = `${protectedHeader}.${payload}`;\n        const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n        if (!verified) {\n            throw new OPE(\"JWT signature verification failed\");\n        }\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(claims)) {\n        throw new OPE(\"JWT Payload must be a top level object\");\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== \"number\") {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== \"number\") {\n            throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== \"string\") {\n            throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== \"number\") {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n        }\n    }\n    return {\n        header,\n        claims,\n        signature,\n        key\n    };\n}\nasync function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    const response = getURLSearchParameter(parameters, \"response\");\n    if (!response) {\n        throw new OPE('\"parameters\" does not contain a JARM response');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const { claims } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n        \"aud\",\n        \"exp\",\n        \"iss\"\n    ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)){\n        if (typeof value === \"string\" && key !== \"aud\") {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(alg, data, key) {\n    let algorithm;\n    switch(alg){\n        case \"RS256\":\n        case \"PS256\":\n        case \"ES256\":\n            algorithm = \"SHA-256\";\n            break;\n        case \"RS384\":\n        case \"PS384\":\n        case \"ES384\":\n            algorithm = \"SHA-384\";\n            break;\n        case \"RS512\":\n        case \"PS512\":\n        case \"ES512\":\n            algorithm = \"SHA-512\";\n            break;\n        case \"EdDSA\":\n            if (key.algorithm.name === \"Ed25519\") {\n                algorithm = \"SHA-512\";\n                break;\n            }\n            throw new UnsupportedOperationError();\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const digest = await crypto.subtle.digest(algorithm, buf(data));\n    return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, alg, key) {\n    const expected = await idTokenHash(alg, data, key);\n    return actual === expected;\n}\nasync function experimental_validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        if (!parameters.hash.length) {\n            throw new TypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters');\n        }\n        parameters = new URLSearchParams(parameters.hash.slice(1));\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams');\n    }\n    parameters = new URLSearchParams(parameters);\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    parameters.delete(\"id_token\");\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new TypeError('\"expectedState\" must be a non-empty string');\n            }\n    }\n    const result = validateAuthResponse({\n        ...as,\n        authorization_response_iss_parameter_supported: false\n    }, client, parameters, expectedState);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!id_token) {\n        throw new OPE('\"parameters\" does not contain an ID Token');\n    }\n    const code = getURLSearchParameter(parameters, \"code\");\n    if (!code) {\n        throw new OPE('\"parameters\" does not contain an Authorization Code');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const requiredClaims = [\n        \"aud\",\n        \"exp\",\n        \"iat\",\n        \"iss\",\n        \"sub\",\n        \"nonce\",\n        \"c_hash\"\n    ];\n    if (typeof expectedState === \"string\") {\n        requiredClaims.push(\"s_hash\");\n    }\n    const { claims, header, key } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const clockSkew = getClockSkew(client);\n    const now = epochTime() + clockSkew;\n    if (claims.iat < now - 3600) {\n        throw new OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past');\n    }\n    if (typeof claims.c_hash !== \"string\" || await idTokenHashMatches(code, claims.c_hash, header.alg, key) !== true) {\n        throw new OPE('invalid ID Token \"c_hash\" (code hash) claim value');\n    }\n    if (claims.s_hash !== undefined && typeof expectedState !== \"string\") {\n        throw new OPE('could not verify ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (typeof expectedState === \"string\" && (typeof claims.s_hash !== \"string\" || await idTokenHashMatches(expectedState, claims.s_hash, header.alg, key) !== true)) {\n        throw new OPE('invalid ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (client.require_auth_time !== undefined && typeof claims.auth_time !== \"number\") {\n        throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    if (!validateString(expectedNonce)) {\n        throw new TypeError('\"expectedNonce\" must be a non-empty string');\n    }\n    if (claims.nonce !== expectedNonce) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n    }\n    if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n        throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n    }\n    return result;\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n    if (client !== undefined) {\n        if (header.alg !== client) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (header.alg !== \"RS256\") {\n        throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw new OPE(`\"${name}\" parameter must be provided only once`);\n    }\n    return value;\n}\nconst skipStateCheck = Symbol();\nconst expectNoState = Symbol();\nfunction validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    if (getURLSearchParameter(parameters, \"response\")) {\n        throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n    }\n    const iss = getURLSearchParameter(parameters, \"iss\");\n    const state = getURLSearchParameter(parameters, \"state\");\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw new OPE('response parameter \"iss\" (issuer) missing');\n    }\n    if (iss && iss !== as.issuer) {\n        throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n    }\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw new OPE('unexpected \"state\" response parameter encountered');\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new OPE('\"expectedState\" must be a non-empty string');\n            }\n            if (state === undefined) {\n                throw new OPE('response parameter \"state\" missing');\n            }\n            if (state !== expectedState) {\n                throw new OPE('unexpected \"state\" response parameter value');\n            }\n    }\n    const error = getURLSearchParameter(parameters, \"error\");\n    if (error) {\n        return {\n            error,\n            error_description: getURLSearchParameter(parameters, \"error_description\"),\n            error_uri: getURLSearchParameter(parameters, \"error_uri\")\n        };\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    const token = getURLSearchParameter(parameters, \"token\");\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n    switch(alg){\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n            return {\n                name: \"RSA-PSS\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"ES256\":\n        case \"ES384\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: `P-${alg.slice(-3)}`\n            };\n        case \"ES512\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-521\"\n            };\n        case \"EdDSA\":\n            {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        return crv;\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey(\"jwk\", key, algToSubtle(alg, jwk.crv), true, [\n        \"verify\"\n    ]);\n}\nasync function deviceAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"device_authorization_endpoint\", options);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.device_code)) {\n        throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.user_code)) {\n        throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.verification_uri)) {\n        throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (json.verification_uri_complete !== undefined && !validateString(json.verification_uri_complete)) {\n        throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n    }\n    if (json.interval !== undefined && (typeof json.interval !== \"number\" || json.interval <= 0)) {\n        throw new OPE('\"response\" body \"interval\" property must be a positive number');\n    }\n    return json;\n}\nasync function deviceCodeGrantRequest(as, client, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(deviceCode)) {\n        throw new TypeError('\"deviceCode\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"device_code\", deviceCode);\n    return tokenEndpointRequest(as, client, \"urn:ietf:params:oauth:grant-type:device_code\", parameters, options);\n}\nasync function processDeviceCodeResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nasync function generateKeyPair(alg, options) {\n    if (!validateString(alg)) {\n        throw new TypeError('\"alg\" must be a non-empty string');\n    }\n    const algorithm = algToSubtle(alg, alg === \"EdDSA\" ? options?.crv ?? \"Ed25519\" : undefined);\n    if (alg.startsWith(\"PS\") || alg.startsWith(\"RS\")) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ])\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\nfunction normalizeHtu(htu) {\n    const url = new URL(htu);\n    url.search = \"\";\n    url.hash = \"\";\n    return url.href;\n}\nasync function validateDPoP(as, request, accessTokenClaims, options) {\n    if (!request.headers.has(\"dpop\")) {\n        throw new OPE(\"operation indicated DPoP use but the request has no DPoP HTTP Header\");\n    }\n    if (request.headers.get(\"authorization\")?.toLowerCase().startsWith(\"dpop \") === false) {\n        throw new OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`);\n    }\n    if (typeof accessTokenClaims.cnf?.jkt !== \"string\") {\n        throw new OPE(\"operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim\");\n    }\n    const clockSkew = getClockSkew(options);\n    const proof = await validateJwt(request.headers.get(\"dpop\"), checkSigningAlgorithm.bind(undefined, undefined, as?.dpop_signing_alg_values_supported || SUPPORTED_JWS_ALGS), async ({ jwk, alg })=>{\n        if (!jwk) {\n            throw new OPE(\"DPoP Proof is missing the jwk header parameter\");\n        }\n        const key = await importJwk(alg, jwk);\n        if (key.type !== \"public\") {\n            throw new OPE(\"DPoP Proof jwk header parameter must contain a public key\");\n        }\n        return key;\n    }, clockSkew, getClockTolerance(options)).then(checkJwtType.bind(undefined, \"dpop+jwt\")).then(validatePresence.bind(undefined, [\n        \"iat\",\n        \"jti\",\n        \"ath\",\n        \"htm\",\n        \"htu\"\n    ]));\n    const now = epochTime() + clockSkew;\n    const diff = Math.abs(now - proof.claims.iat);\n    if (diff > 300) {\n        throw new OPE(\"DPoP Proof iat is not recent enough\");\n    }\n    if (proof.claims.htm !== request.method) {\n        throw new OPE(\"DPoP Proof htm mismatch\");\n    }\n    if (typeof proof.claims.htu !== \"string\" || normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n        throw new OPE(\"DPoP Proof htu mismatch\");\n    }\n    {\n        const accessToken = request.headers.get(\"authorization\").split(\" \")[1];\n        const expected = b64u(await crypto.subtle.digest(\"SHA-256\", encoder.encode(accessToken)));\n        if (proof.claims.ath !== expected) {\n            throw new OPE(\"DPoP Proof ath mismatch\");\n        }\n    }\n    {\n        let components;\n        switch(proof.header.jwk.kty){\n            case \"EC\":\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x,\n                    y: proof.header.jwk.y\n                };\n                break;\n            case \"OKP\":\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x\n                };\n                break;\n            case \"RSA\":\n                components = {\n                    e: proof.header.jwk.e,\n                    kty: proof.header.jwk.kty,\n                    n: proof.header.jwk.n\n                };\n                break;\n            default:\n                throw new UnsupportedOperationError();\n        }\n        const expected = b64u(await crypto.subtle.digest(\"SHA-256\", encoder.encode(JSON.stringify(components))));\n        if (accessTokenClaims.cnf.jkt !== expected) {\n            throw new OPE(\"JWT Access Token confirmation mismatch\");\n        }\n    }\n}\nasync function experimental_validateJwtAccessToken(as, request, expectedAudience, options) {\n    assertAs(as);\n    if (!looseInstanceOf(request, Request)) {\n        throw new TypeError('\"request\" must be an instance of Request');\n    }\n    if (!validateString(expectedAudience)) {\n        throw new OPE('\"expectedAudience\" must be a non-empty string');\n    }\n    const authorization = request.headers.get(\"authorization\");\n    if (!authorization) {\n        throw new OPE('\"request\" is missing an Authorization HTTP Header');\n    }\n    let { 0: scheme, 1: accessToken, length } = authorization.split(\" \");\n    scheme = scheme.toLowerCase();\n    switch(scheme){\n        case \"dpop\":\n        case \"bearer\":\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported Authorization HTTP Header scheme\");\n    }\n    if (length !== 2) {\n        throw new OPE(\"invalid Authorization HTTP Header format\");\n    }\n    const requiredClaims = [\n        \"iss\",\n        \"exp\",\n        \"aud\",\n        \"sub\",\n        \"iat\",\n        \"jti\",\n        \"client_id\"\n    ];\n    if (options?.requireDPoP || scheme === \"dpop\" || request.headers.has(\"dpop\")) {\n        requiredClaims.push(\"cnf\");\n    }\n    const { claims } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, undefined, SUPPORTED_JWS_ALGS), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(options), getClockTolerance(options)).then(checkJwtType.bind(undefined, \"at+jwt\")).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, expectedAudience));\n    for (const claim of [\n        \"client_id\",\n        \"jti\",\n        \"sub\"\n    ]){\n        if (typeof claims[claim] !== \"string\") {\n            throw new OPE(`unexpected JWT \"${claim}\" claim type`);\n        }\n    }\n    if (\"cnf\" in claims) {\n        if (!isJsonObject(claims.cnf)) {\n            throw new OPE('unexpected JWT \"cnf\" (confirmation) claim value');\n        }\n        const { 0: cnf, length } = Object.keys(claims.cnf);\n        if (length) {\n            if (length !== 1) {\n                throw new UnsupportedOperationError(\"multiple confirmation claims are not supported\");\n            }\n            if (cnf !== \"jkt\") {\n                throw new UnsupportedOperationError(\"unsupported JWT Confirmation method\");\n            }\n        }\n    }\n    if (options?.requireDPoP || scheme === \"dpop\" || claims.cnf?.jkt !== undefined || request.headers.has(\"dpop\")) {\n        await validateDPoP(as, request, claims, options);\n    }\n    return claims;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb2F1dGg0d2ViYXBpL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBO0FBQ0osSUFBSSxPQUFPQyxjQUFjLGVBQWUsQ0FBQ0EsVUFBVUMsU0FBUyxFQUFFQyxhQUFhLGlCQUFpQjtJQUN4RixNQUFNQyxPQUFPO0lBQ2IsTUFBTUMsVUFBVTtJQUNoQkwsYUFBYSxDQUFDLEVBQUVJLEtBQUssQ0FBQyxFQUFFQyxRQUFRLENBQUM7QUFDckM7QUFDQSxTQUFTQyxnQkFBZ0JDLEtBQUssRUFBRUMsUUFBUTtJQUNwQyxJQUFJRCxTQUFTLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsT0FBUUEsaUJBQWlCQyxZQUNyQkMsT0FBT0MsY0FBYyxDQUFDSCxNQUFNLENBQUNJLE9BQU9DLFdBQVcsQ0FBQyxLQUFLSixTQUFTSyxTQUFTLENBQUNGLE9BQU9DLFdBQVcsQ0FBQztJQUNuRyxFQUNBLE9BQU07UUFDRixPQUFPO0lBQ1g7QUFDSjtBQUNPLE1BQU1FLFlBQVlILFNBQVM7QUFDM0IsTUFBTUksaUJBQWlCSixTQUFTO0FBQ2hDLE1BQU1LLDJCQUEyQkwsU0FBUztBQUMxQyxNQUFNTSwwQkFBMEJELHlCQUF5QjtBQUN6RCxNQUFNRSw0QkFBNEJQLFNBQVM7QUFDM0MsTUFBTVEsMkJBQTJCRCwwQkFBMEI7QUFDbEUsTUFBTUUsVUFBVSxJQUFJQztBQUNwQixNQUFNQyxVQUFVLElBQUlDO0FBQ3BCLFNBQVNDLElBQUlqQixLQUFLO0lBQ2QsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsT0FBT2EsUUFBUUssTUFBTSxDQUFDbEI7SUFDMUI7SUFDQSxPQUFPZSxRQUFRSSxNQUFNLENBQUNuQjtBQUMxQjtBQUNBLE1BQU1vQixhQUFhO0FBQ25CLFNBQVNDLGdCQUFnQnJCLEtBQUs7SUFDMUIsSUFBSUEsaUJBQWlC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TztnQkFDZixNQUFNLElBQUkxUCwwQkFBMEI7WUFDeEM7UUFDSjtJQUNKO0lBQ0EsSUFBSU0sU0FBUzZVLGVBQ1Q5SyxXQUFXLFVBQ1h2QyxPQUFPNEgsR0FBRyxFQUFFZ0YsUUFBUWhWLGFBQ3BCOFUsUUFBUXhULE9BQU8sQ0FBQ3JCLEdBQUcsQ0FBQyxTQUFTO1FBQzdCLE1BQU00VSxhQUFhN08sSUFBSThPLFNBQVMxTSxRQUFReEg7SUFDNUM7SUFDQSxPQUFPd0g7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYXV0aDR3ZWJhcGkvYnVpbGQvaW5kZXguanM/M2Q0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgVVNFUl9BR0VOVDtcbmlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLnVzZXJBZ2VudD8uc3RhcnRzV2l0aD8uKCdNb3ppbGxhLzUuMCAnKSkge1xuICAgIGNvbnN0IE5BTUUgPSAnb2F1dGg0d2ViYXBpJztcbiAgICBjb25zdCBWRVJTSU9OID0gJ3YyLjguMSc7XG4gICAgVVNFUl9BR0VOVCA9IGAke05BTUV9LyR7VkVSU0lPTn1gO1xufVxuZnVuY3Rpb24gbG9vc2VJbnN0YW5jZU9mKGlucHV0LCBleHBlY3RlZCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChpbnB1dCBpbnN0YW5jZW9mIGV4cGVjdGVkIHx8XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IGV4cGVjdGVkLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGNsb2NrU2tldyA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGNsb2NrVG9sZXJhbmNlID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgZXhwZXJpbWVudGFsX2N1c3RvbUZldGNoID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgZXhwZXJpbWVudGFsQ3VzdG9tRmV0Y2ggPSBleHBlcmltZW50YWxfY3VzdG9tRmV0Y2g7XG5leHBvcnQgY29uc3QgZXhwZXJpbWVudGFsX3VzZU10bHNBbGlhcyA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbFVzZU10bHNBbGlhcyA9IGV4cGVyaW1lbnRhbF91c2VNdGxzQWxpYXM7XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBidWYoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoaW5wdXQpO1xufVxuY29uc3QgQ0hVTktfU0laRSA9IDB4ODAwMDtcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NFVybChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH1cbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmJ5dGVMZW5ndGg7IGkgKz0gQ0hVTktfU0laRSkge1xuICAgICAgICBhcnIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlucHV0LnN1YmFycmF5KGksIGkgKyBDSFVOS19TSVpFKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShhcnIuam9pbignJykpLnJlcGxhY2UoLz0vZywgJycpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xufVxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0VXJsKGlucHV0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmluYXJ5ID0gYXRvYihpbnB1dC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdUaGUgaW5wdXQgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuJywgeyBjYXVzZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBiNjR1KGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZUJhc2U2NFVybChpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVCYXNlNjRVcmwoaW5wdXQpO1xufVxuY2xhc3MgTFJVIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhTaXplKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodiA9IHRoaXMuX2NhY2hlLmdldChrZXkpKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoa2V5LCB2KTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSkgfHwgdGhpcy5fY2FjaGUuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5zaXplID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnb3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmNvbnN0IE9QRSA9IE9wZXJhdGlvblByb2Nlc3NpbmdFcnJvcjtcbmNvbnN0IGRwb3BOb25jZXMgPSBuZXcgTFJVKDEwMCk7XG5mdW5jdGlvbiBpc0NyeXB0b0tleShrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5O1xufVxuZnVuY3Rpb24gaXNQcml2YXRlS2V5KGtleSkge1xuICAgIHJldHVybiBpc0NyeXB0b0tleShrZXkpICYmIGtleS50eXBlID09PSAncHJpdmF0ZSc7XG59XG5mdW5jdGlvbiBpc1B1YmxpY0tleShrZXkpIHtcbiAgICByZXR1cm4gaXNDcnlwdG9LZXkoa2V5KSAmJiBrZXkudHlwZSA9PT0gJ3B1YmxpYyc7XG59XG5jb25zdCBTVVBQT1JURURfSldTX0FMR1MgPSBbXG4gICAgJ1BTMjU2JyxcbiAgICAnRVMyNTYnLFxuICAgICdSUzI1NicsXG4gICAgJ1BTMzg0JyxcbiAgICAnRVMzODQnLFxuICAgICdSUzM4NCcsXG4gICAgJ1BTNTEyJyxcbiAgICAnRVM1MTInLFxuICAgICdSUzUxMicsXG4gICAgJ0VkRFNBJyxcbl07XG5mdW5jdGlvbiBwcm9jZXNzRHBvcE5vbmNlKHJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuaGFzKCdkcG9wLW5vbmNlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVzcG9uc2UudXJsKTtcbiAgICAgICAgICAgIGRwb3BOb25jZXMuc2V0KHVybC5vcmlnaW4sIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdkcG9wLW5vbmNlJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplVHlwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXmFwcGxpY2F0aW9uXFwvLywgJycpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVIZWFkZXJzKGlucHV0KSB7XG4gICAgaWYgKGxvb3NlSW5zdGFuY2VPZihpbnB1dCwgSGVhZGVycykpIHtcbiAgICAgICAgaW5wdXQgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5wdXQuZW50cmllcygpKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0KTtcbiAgICBpZiAoVVNFUl9BR0VOVCAmJiAhaGVhZGVycy5oYXMoJ3VzZXItYWdlbnQnKSkge1xuICAgICAgICBoZWFkZXJzLnNldCgndXNlci1hZ2VudCcsIFVTRVJfQUdFTlQpO1xuICAgIH1cbiAgICBpZiAoaGVhZGVycy5oYXMoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuaGVhZGVyc1wiIG11c3Qgbm90IGluY2x1ZGUgdGhlIFwiYXV0aG9yaXphdGlvblwiIGhlYWRlciBuYW1lJyk7XG4gICAgfVxuICAgIGlmIChoZWFkZXJzLmhhcygnZHBvcCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5oZWFkZXJzXCIgbXVzdCBub3QgaW5jbHVkZSB0aGUgXCJkcG9wXCIgaGVhZGVyIG5hbWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBzaWduYWwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLnNpZ25hbFwiIG11c3QgcmV0dXJuIG9yIGJlIGFuIGluc3RhbmNlIG9mIEFib3J0U2lnbmFsJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNjb3ZlcnlSZXF1ZXN0KGlzc3VlcklkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShpc3N1ZXJJZGVudGlmaWVyIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlzc3VlcklkZW50aWZpZXJcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcpO1xuICAgIH1cbiAgICBpZiAoaXNzdWVySWRlbnRpZmllci5wcm90b2NvbCAhPT0gJ2h0dHBzOicgJiYgaXNzdWVySWRlbnRpZmllci5wcm90b2NvbCAhPT0gJ2h0dHA6Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlzc3Vlci5wcm90b2NvbFwiIG11c3QgYmUgXCJodHRwczpcIiBvciBcImh0dHA6XCInKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChpc3N1ZXJJZGVudGlmaWVyLmhyZWYpO1xuICAgIHN3aXRjaCAob3B0aW9ucz8uYWxnb3JpdGhtKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdvaWRjJzpcbiAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IGAke3VybC5wYXRobmFtZX0vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYXV0aDInOlxuICAgICAgICAgICAgaWYgKHVybC5wYXRobmFtZSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgdXJsLnBhdGhuYW1lID0gYC53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IGAud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlci8ke3VybC5wYXRobmFtZX1gLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmFsZ29yaXRobVwiIG11c3QgYmUgXCJvaWRjXCIgKGRlZmF1bHQpLCBvciBcIm9hdXRoMlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICByZXR1cm4gKG9wdGlvbnM/LltleHBlcmltZW50YWxfY3VzdG9tRmV0Y2hdIHx8IGZldGNoKSh1cmwuaHJlZiwge1xuICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgaW5wdXQubGVuZ3RoICE9PSAwO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEaXNjb3ZlcnlSZXNwb25zZShleHBlY3RlZElzc3VlcklkZW50aWZpZXIsIHJlc3BvbnNlKSB7XG4gICAgaWYgKCEoZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4cGVjdGVkSXNzdWVyXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwnKTtcbiAgICB9XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gQXV0aG9yaXphdGlvbiBTZXJ2ZXIgTWV0YWRhdGEgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLmlzc3VlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpc3N1ZXJcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAobmV3IFVSTChqc29uLmlzc3VlcikuaHJlZiAhPT0gZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyLmhyZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpc3N1ZXJcIiBkb2VzIG5vdCBtYXRjaCBcImV4cGVjdGVkSXNzdWVyXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5mdW5jdGlvbiByYW5kb21CeXRlcygpIHtcbiAgICByZXR1cm4gYjY0dShjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tQ29kZVZlcmlmaWVyKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tU3RhdGUoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21Ob25jZSgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVQS0NFQ29kZUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNvZGVWZXJpZmllcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjb2RlVmVyaWZpZXJcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gYjY0dShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGJ1Zihjb2RlVmVyaWZpZXIpKSk7XG59XG5mdW5jdGlvbiBnZXRLZXlBbmRLaWQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDcnlwdG9LZXkpIHtcbiAgICAgICAgcmV0dXJuIHsga2V5OiBpbnB1dCB9O1xuICAgIH1cbiAgICBpZiAoIShpbnB1dD8ua2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5KSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChpbnB1dC5raWQgIT09IHVuZGVmaW5lZCAmJiAhdmFsaWRhdGVTdHJpbmcoaW5wdXQua2lkKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImtpZFwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiB7IGtleTogaW5wdXQua2V5LCBraWQ6IGlucHV0LmtpZCB9O1xufVxuZnVuY3Rpb24gZm9ybVVybEVuY29kZSh0b2tlbikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodG9rZW4pLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufVxuZnVuY3Rpb24gY2xpZW50U2VjcmV0QmFzaWMoY2xpZW50SWQsIGNsaWVudFNlY3JldCkge1xuICAgIGNvbnN0IHVzZXJuYW1lID0gZm9ybVVybEVuY29kZShjbGllbnRJZCk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBmb3JtVXJsRW5jb2RlKGNsaWVudFNlY3JldCk7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBidG9hKGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWApO1xuICAgIHJldHVybiBgQmFzaWMgJHtjcmVkZW50aWFsc31gO1xufVxuZnVuY3Rpb24gcHNBbGcoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnUFMyNTYnO1xuICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnUFMzODQnO1xuICAgICAgICBjYXNlICdTSEEtNTEyJzpcbiAgICAgICAgICAgIHJldHVybiAnUFM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIFJzYUhhc2hlZEtleUFsZ29yaXRobSBoYXNoIG5hbWUnKTtcbiAgICB9XG59XG5mdW5jdGlvbiByc0FsZyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0uaGFzaC5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdSUzI1Nic7XG4gICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdSUzM4NCc7XG4gICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgcmV0dXJuICdSUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgUnNhSGFzaGVkS2V5QWxnb3JpdGhtIGhhc2ggbmFtZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzQWxnKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKSB7XG4gICAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnRVMyNTYnO1xuICAgICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ0VTMzg0JztcbiAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgICAgcmV0dXJuICdFUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgRWNLZXlBbGdvcml0aG0gbmFtZWRDdXJ2ZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleVRvSndzKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ1JTQS1QU1MnOlxuICAgICAgICAgICAgcmV0dXJuIHBzQWxnKGtleSk7XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcbiAgICAgICAgICAgIHJldHVybiByc0FsZyhrZXkpO1xuICAgICAgICBjYXNlICdFQ0RTQSc6XG4gICAgICAgICAgICByZXR1cm4gZXNBbGcoa2V5KTtcbiAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgIGNhc2UgJ0VkNDQ4JzpcbiAgICAgICAgICAgIHJldHVybiAnRWREU0EnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIENyeXB0b0tleSBhbGdvcml0aG0gbmFtZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENsb2NrU2tldyhjbGllbnQpIHtcbiAgICBpZiAoY2xpZW50ICYmIGNsb2NrU2tldyBpbiBjbGllbnQpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjbGllbnRbY2xvY2tTa2V3XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRbY2xvY2tTa2V3XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkge1xuICAgIGlmIChjbGllbnQgJiYgY2xvY2tUb2xlcmFuY2UgaW4gY2xpZW50KSB7XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNsaWVudFtjbG9ja1RvbGVyYW5jZV07XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodG9sZXJhbmNlKSAmJiBNYXRoLnNpZ24odG9sZXJhbmNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDMwO1xufVxuZnVuY3Rpb24gZXBvY2hUaW1lKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbn1cbmZ1bmN0aW9uIGNsaWVudEFzc2VydGlvbihhcywgY2xpZW50KSB7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBqdGk6IHJhbmRvbUJ5dGVzKCksXG4gICAgICAgIGF1ZDogW2FzLmlzc3VlciwgYXMudG9rZW5fZW5kcG9pbnRdLFxuICAgICAgICBleHA6IG5vdyArIDYwLFxuICAgICAgICBpYXQ6IG5vdyxcbiAgICAgICAgbmJmOiBub3csXG4gICAgICAgIGlzczogY2xpZW50LmNsaWVudF9pZCxcbiAgICAgICAgc3ViOiBjbGllbnQuY2xpZW50X2lkLFxuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiBwcml2YXRlS2V5Snd0KGFzLCBjbGllbnQsIGtleSwga2lkKSB7XG4gICAgcmV0dXJuIGp3dCh7XG4gICAgICAgIGFsZzoga2V5VG9Kd3Moa2V5KSxcbiAgICAgICAga2lkLFxuICAgIH0sIGNsaWVudEFzc2VydGlvbihhcywgY2xpZW50KSwga2V5KTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFzKGFzKSB7XG4gICAgaWYgKHR5cGVvZiBhcyAhPT0gJ29iamVjdCcgfHwgYXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhc1wiIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoYXMuaXNzdWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmlzc3VlclwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xpZW50KGNsaWVudCkge1xuICAgIGlmICh0eXBlb2YgY2xpZW50ICE9PSAnb2JqZWN0JyB8fCBjbGllbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjbGllbnRcIiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNsaWVudC5jbGllbnRfaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2xpZW50LmNsaWVudF9pZFwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xpZW50U2VjcmV0KGNsaWVudFNlY3JldCkge1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoY2xpZW50U2VjcmV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNsaWVudC5jbGllbnRfc2VjcmV0XCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudFNlY3JldDtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleShjbGllbnRBdXRoTWV0aG9kLCBjbGllbnRQcml2YXRlS2V5KSB7XG4gICAgaWYgKGNsaWVudFByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleVwiIHByb3BlcnR5IG11c3Qgbm90IGJlIHByb3ZpZGVkIHdoZW4gJHtjbGllbnRBdXRoTWV0aG9kfSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIGlzIHVzZWQuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Tm9DbGllbnRTZWNyZXQoY2xpZW50QXV0aE1ldGhvZCwgY2xpZW50U2VjcmV0KSB7XG4gICAgaWYgKGNsaWVudFNlY3JldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiY2xpZW50LmNsaWVudF9zZWNyZXRcIiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBwcm92aWRlZCB3aGVuICR7Y2xpZW50QXV0aE1ldGhvZH0gY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBpcyB1c2VkLmApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNsaWVudEF1dGhlbnRpY2F0aW9uKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMsIGNsaWVudFByaXZhdGVLZXkpIHtcbiAgICBib2R5LmRlbGV0ZSgnY2xpZW50X3NlY3JldCcpO1xuICAgIGJvZHkuZGVsZXRlKCdjbGllbnRfYXNzZXJ0aW9uX3R5cGUnKTtcbiAgICBib2R5LmRlbGV0ZSgnY2xpZW50X2Fzc2VydGlvbicpO1xuICAgIHN3aXRjaCAoY2xpZW50LnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdjbGllbnRfc2VjcmV0X2Jhc2ljJzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRQcml2YXRlS2V5KCdjbGllbnRfc2VjcmV0X2Jhc2ljJywgY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGNsaWVudFNlY3JldEJhc2ljKGNsaWVudC5jbGllbnRfaWQsIGFzc2VydENsaWVudFNlY3JldChjbGllbnQuY2xpZW50X3NlY3JldCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfcG9zdCc6IHtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleSgnY2xpZW50X3NlY3JldF9wb3N0JywgY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X3NlY3JldCcsIGFzc2VydENsaWVudFNlY3JldChjbGllbnQuY2xpZW50X3NlY3JldCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncHJpdmF0ZV9rZXlfand0Jzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRTZWNyZXQoJ3ByaXZhdGVfa2V5X2p3dCcsIGNsaWVudC5jbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIGlmIChjbGllbnRQcml2YXRlS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleVwiIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBcImNsaWVudC50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZFwiIGlzIFwicHJpdmF0ZV9rZXlfand0XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCBraWQgfSA9IGdldEtleUFuZEtpZChjbGllbnRQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGlmICghaXNQcml2YXRlS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleS5rZXlcIiBtdXN0IGJlIGEgcHJpdmF0ZSBDcnlwdG9LZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfYXNzZXJ0aW9uX3R5cGUnLCAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyJyk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2Fzc2VydGlvbicsIGF3YWl0IHByaXZhdGVLZXlKd3QoYXMsIGNsaWVudCwga2V5LCBraWQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Rsc19jbGllbnRfYXV0aCc6XG4gICAgICAgIGNhc2UgJ3NlbGZfc2lnbmVkX3Rsc19jbGllbnRfYXV0aCc6XG4gICAgICAgIGNhc2UgJ25vbmUnOiB7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFNlY3JldChjbGllbnQudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QsIGNsaWVudC5jbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleShjbGllbnQudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QsIGNsaWVudFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBjbGllbnQgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QnKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBqd3QoaGVhZGVyLCBjbGFpbXNTZXQsIGtleSkge1xuICAgIGlmICgha2V5LnVzYWdlcy5pbmNsdWRlcygnc2lnbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NyeXB0b0tleSBpbnN0YW5jZXMgdXNlZCBmb3Igc2lnbmluZyBhc3NlcnRpb25zIG11c3QgaW5jbHVkZSBcInNpZ25cIiBpbiB0aGVpciBcInVzYWdlc1wiJyk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gYCR7YjY0dShidWYoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSkpfS4ke2I2NHUoYnVmKEpTT04uc3RyaW5naWZ5KGNsYWltc1NldCkpKX1gO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKGtleVRvU3VidGxlKGtleSksIGtleSwgYnVmKGlucHV0KSkpO1xuICAgIHJldHVybiBgJHtpbnB1dH0uJHtzaWduYXR1cmV9YDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc3N1ZVJlcXVlc3RPYmplY3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgcHJpdmF0ZUtleSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCB7IGtleSwga2lkIH0gPSBnZXRLZXlBbmRLaWQocHJpdmF0ZUtleSk7XG4gICAgaWYgKCFpc1ByaXZhdGVLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInByaXZhdGVLZXkua2V5XCIgbXVzdCBiZSBhIHByaXZhdGUgQ3J5cHRvS2V5Jyk7XG4gICAgfVxuICAgIHBhcmFtZXRlcnMuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgIGNvbnN0IGNsYWltcyA9IHtcbiAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtZXRlcnMuZW50cmllcygpKSxcbiAgICAgICAganRpOiByYW5kb21CeXRlcygpLFxuICAgICAgICBhdWQ6IGFzLmlzc3VlcixcbiAgICAgICAgZXhwOiBub3cgKyA2MCxcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIG5iZjogbm93LFxuICAgICAgICBpc3M6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgfTtcbiAgICBsZXQgcmVzb3VyY2U7XG4gICAgaWYgKHBhcmFtZXRlcnMuaGFzKCdyZXNvdXJjZScpICYmXG4gICAgICAgIChyZXNvdXJjZSA9IHBhcmFtZXRlcnMuZ2V0QWxsKCdyZXNvdXJjZScpKSAmJlxuICAgICAgICByZXNvdXJjZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNsYWltcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVycy5oYXMoJ2NsYWltcycpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1ldGVycy5nZXQoJ2NsYWltcycpO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImNsYWltc1wiIHBhcmFtZXRlciBtdXN0IGJlIHBhc3NlZCBhcyBhIFVURi04IGVuY29kZWQgSlNPTicpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGFpbXMuY2xhaW1zID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgdGhlIFwiY2xhaW1zXCIgcGFyYW1ldGVyIGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcy5jbGFpbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImNsYWltc1wiIHBhcmFtZXRlciBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqd3Qoe1xuICAgICAgICBhbGc6IGtleVRvSndzKGtleSksXG4gICAgICAgIHR5cDogJ29hdXRoLWF1dGh6LXJlcStqd3QnLFxuICAgICAgICBraWQsXG4gICAgfSwgY2xhaW1zLCBrZXkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMsIHVybCwgaHRtLCBjbG9ja1NrZXcsIGFjY2Vzc1Rva2VuKSB7XG4gICAgY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXksIG5vbmNlID0gZHBvcE5vbmNlcy5nZXQodXJsLm9yaWdpbikgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFpc1ByaXZhdGVLZXkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJEUG9QLnByaXZhdGVLZXlcIiBtdXN0IGJlIGEgcHJpdmF0ZSBDcnlwdG9LZXknKTtcbiAgICB9XG4gICAgaWYgKCFpc1B1YmxpY0tleShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5wdWJsaWNLZXlcIiBtdXN0IGJlIGEgcHVibGljIENyeXB0b0tleScpO1xuICAgIH1cbiAgICBpZiAobm9uY2UgIT09IHVuZGVmaW5lZCAmJiAhdmFsaWRhdGVTdHJpbmcobm9uY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5ub25jZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoIXB1YmxpY0tleS5leHRyYWN0YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1AucHVibGljS2V5LmV4dHJhY3RhYmxlXCIgbXVzdCBiZSB0cnVlJyk7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGNvbnN0IHByb29mID0gYXdhaXQgand0KHtcbiAgICAgICAgYWxnOiBrZXlUb0p3cyhwcml2YXRlS2V5KSxcbiAgICAgICAgdHlwOiAnZHBvcCtqd3QnLFxuICAgICAgICBqd2s6IGF3YWl0IHB1YmxpY0p3ayhwdWJsaWNLZXkpLFxuICAgIH0sIHtcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgaHRtLFxuICAgICAgICBub25jZSxcbiAgICAgICAgaHR1OiBgJHt1cmwub3JpZ2lufSR7dXJsLnBhdGhuYW1lfWAsXG4gICAgICAgIGF0aDogYWNjZXNzVG9rZW4gPyBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGFjY2Vzc1Rva2VuKSkpIDogdW5kZWZpbmVkLFxuICAgIH0sIHByaXZhdGVLZXkpO1xuICAgIGhlYWRlcnMuc2V0KCdkcG9wJywgcHJvb2YpO1xufVxubGV0IGp3a0NhY2hlO1xuYXN5bmMgZnVuY3Rpb24gcHVibGljSndrKGtleSkge1xuICAgIGp3a0NhY2hlIHx8IChqd2tDYWNoZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAgIGlmIChqd2tDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gandrQ2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsga3R5LCBlLCBuLCB4LCB5LCBjcnYgfSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBrZXkpO1xuICAgIGNvbnN0IGp3ayA9IHsga3R5LCBlLCBuLCB4LCB5LCBjcnYgfTtcbiAgICBqd2tDYWNoZS5zZXQoa2V5LCBqd2spO1xuICAgIHJldHVybiBqd2s7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUVuZHBvaW50KHZhbHVlLCBlbmRwb2ludCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChvcHRpb25zPy5bZXhwZXJpbWVudGFsX3VzZU10bHNBbGlhc10pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiYXMubXRsc19lbmRwb2ludF9hbGlhc2VzLiR7ZW5kcG9pbnR9XCIgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJhcy4ke2VuZHBvaW50fVwiIG11c3QgYmUgYSBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVSTCh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5kcG9pbnQoYXMsIGVuZHBvaW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnM/LltleHBlcmltZW50YWxfdXNlTXRsc0FsaWFzXSAmJlxuICAgICAgICBhcy5tdGxzX2VuZHBvaW50X2FsaWFzZXMgJiZcbiAgICAgICAgZW5kcG9pbnQgaW4gYXMubXRsc19lbmRwb2ludF9hbGlhc2VzKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVuZHBvaW50KGFzLm10bHNfZW5kcG9pbnRfYWxpYXNlc1tlbmRwb2ludF0sIGVuZHBvaW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlRW5kcG9pbnQoYXNbZW5kcG9pbnRdLCBlbmRwb2ludCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHVzaGVkQXV0aG9yaXphdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdwdXNoZWRfYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2VuZHBvaW50Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IGRwb3BQcm9vZkp3dChoZWFkZXJzLCBvcHRpb25zLkRQb1AsIHVybCwgJ1BPU1QnLCBnZXRDbG9ja1NrZXcoY2xpZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCAnUE9TVCcsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPQXV0aDJFcnJvcihpbnB1dCkge1xuICAgIGNvbnN0IHZhbHVlID0gaW5wdXQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuZXJyb3IgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdmFsdWVbMF0gPT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgU1BMSVRfUkVHRVhQID0gLygoPzosfCwgKT9bMC05YS16QS1aISMkJSYnKistLl5fYHx+XSs9KS87XG5jb25zdCBTQ0hFTUVTX1JFR0VYUCA9IC8oPzpefCwgPykoWzAtOWEtekEtWiEjJCUmJyorXFwtLl5fYHx+XSspKD89JHxbICxdKS9nO1xuZnVuY3Rpb24gd3d3QXV0aChzY2hlbWUsIHBhcmFtcykge1xuICAgIGNvbnN0IGFyciA9IHBhcmFtcy5zcGxpdChTUExJVF9SRUdFWFApLnNsaWNlKDEpO1xuICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBzY2hlbWU6IHNjaGVtZS50b0xvd2VyQ2FzZSgpLCBwYXJhbWV0ZXJzOiB7fSB9O1xuICAgIH1cbiAgICBhcnJbYXJyLmxlbmd0aCAtIDFdID0gYXJyW2Fyci5sZW5ndGggLSAxXS5yZXBsYWNlKC8sJC8sICcnKTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaTtcbiAgICAgICAgaWYgKGFycltpZHhdWzBdID09PSAnXCInKSB7XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2lkeF0uc2xpY2UoLTEpICE9PSAnXCInICYmICsraSA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhcnJbaWR4XSArPSBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gYXJyW2lkeCAtIDFdLnJlcGxhY2UoL14oPzosID8pfD0kL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBwYXJhbWV0ZXJzW2tleV0gPSB1bnF1b3RlKGFycltpZHhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiBzY2hlbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcGFyYW1ldGVycyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlV3d3QXV0aGVudGljYXRlQ2hhbGxlbmdlcyhyZXNwb25zZSkge1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5oZWFkZXJzLmhhcygnd3d3LWF1dGhlbnRpY2F0ZScpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCB7IDE6IHNjaGVtZSwgaW5kZXggfSBvZiBoZWFkZXIubWF0Y2hBbGwoU0NIRU1FU19SRUdFWFApKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtzY2hlbWUsIGluZGV4XSk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0gcmVzdWx0Lm1hcCgoW3NjaGVtZSwgaW5kZXhPZl0sIGksIG90aGVycykgPT4ge1xuICAgICAgICBjb25zdCBuZXh0ID0gb3RoZXJzW2kgKyAxXTtcbiAgICAgICAgbGV0IHBhcmFtZXRlcnM7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0gaGVhZGVyLnNsaWNlKGluZGV4T2YsIG5leHRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IGhlYWRlci5zbGljZShpbmRleE9mKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3d3QXV0aChzY2hlbWUsIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBjaGFsbGVuZ2VzO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NQdXNoZWRBdXRob3JpemF0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDEpIHtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKChlcnIgPSBhd2FpdCBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIFB1c2hlZCBBdXRob3JpemF0aW9uIFJlcXVlc3QgRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnJlcXVlc3RfdXJpKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInJlcXVlc3RfdXJpXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInIHx8IGpzb24uZXhwaXJlc19pbiA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiZXhwaXJlc19pblwiIHByb3BlcnR5IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvdGVjdGVkUmVzb3VyY2VSZXF1ZXN0KGFjY2Vzc1Rva2VuLCBtZXRob2QsIHVybCwgaGVhZGVycywgYm9keSwgb3B0aW9ucykge1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoYWNjZXNzVG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWNjZXNzVG9rZW5cIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widXJsXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwnKTtcbiAgICB9XG4gICAgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhd2FpdCBkcG9wUHJvb2ZKd3QoaGVhZGVycywgb3B0aW9ucy5EUG9QLCB1cmwsICdHRVQnLCBnZXRDbG9ja1NrZXcoeyBbY2xvY2tTa2V3XTogb3B0aW9ucz8uW2Nsb2NrU2tld10gfSksIGFjY2Vzc1Rva2VuKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2F1dGhvcml6YXRpb24nLCBgRFBvUCAke2FjY2Vzc1Rva2VufWApO1xuICAgIH1cbiAgICByZXR1cm4gKG9wdGlvbnM/LltleHBlcmltZW50YWxfY3VzdG9tRmV0Y2hdIHx8IGZldGNoKSh1cmwuaHJlZiwge1xuICAgICAgICBib2R5LFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgPyBzaWduYWwob3B0aW9ucy5zaWduYWwpIDogbnVsbCxcbiAgICB9KS50aGVuKHByb2Nlc3NEcG9wTm9uY2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVzZXJJbmZvUmVxdWVzdChhcywgY2xpZW50LCBhY2Nlc3NUb2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICd1c2VyaW5mb19lbmRwb2ludCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50LnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qd3QnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICBoZWFkZXJzLmFwcGVuZCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3dCcpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdGVjdGVkUmVzb3VyY2VSZXF1ZXN0KGFjY2Vzc1Rva2VuLCAnR0VUJywgdXJsLCBoZWFkZXJzLCBudWxsLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIFtjbG9ja1NrZXddOiBnZXRDbG9ja1NrZXcoY2xpZW50KSxcbiAgICB9KTtcbn1cbmxldCBqd2tzQ2FjaGU7XG5hc3luYyBmdW5jdGlvbiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKSB7XG4gICAgY29uc3QgeyBhbGcsIGtpZCB9ID0gaGVhZGVyO1xuICAgIGNoZWNrU3VwcG9ydGVkSndzQWxnKGFsZyk7XG4gICAgbGV0IGp3a3M7XG4gICAgbGV0IGFnZTtcbiAgICBqd2tzQ2FjaGUgfHwgKGp3a3NDYWNoZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAgIGlmIChqd2tzQ2FjaGUuaGFzKGFzKSkge1xuICAgICAgICA7XG4gICAgICAgICh7IGp3a3MsIGFnZSB9ID0gandrc0NhY2hlLmdldChhcykpO1xuICAgICAgICBpZiAoYWdlID49IDMwMCkge1xuICAgICAgICAgICAgandrc0NhY2hlLmRlbGV0ZShhcyk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGp3a3MgPSBhd2FpdCBqd2tzUmVxdWVzdChhcywgb3B0aW9ucykudGhlbihwcm9jZXNzSndrc1Jlc3BvbnNlKTtcbiAgICAgICAgYWdlID0gMDtcbiAgICAgICAgandrc0NhY2hlLnNldChhcywge1xuICAgICAgICAgICAgandrcyxcbiAgICAgICAgICAgIGlhdDogZXBvY2hUaW1lKCksXG4gICAgICAgICAgICBnZXQgYWdlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcG9jaFRpbWUoKSAtIHRoaXMuaWF0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBrdHk7XG4gICAgc3dpdGNoIChhbGcuc2xpY2UoMCwgMikpIHtcbiAgICAgICAgY2FzZSAnUlMnOlxuICAgICAgICBjYXNlICdQUyc6XG4gICAgICAgICAgICBrdHkgPSAnUlNBJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFUyc6XG4gICAgICAgICAgICBrdHkgPSAnRUMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VkJzpcbiAgICAgICAgICAgIGt0eSA9ICdPS1AnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBjYW5kaWRhdGVzID0gandrcy5rZXlzLmZpbHRlcigoandrKSA9PiB7XG4gICAgICAgIGlmIChqd2sua3R5ICE9PSBrdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2lkICE9PSB1bmRlZmluZWQgJiYga2lkICE9PSBqd2sua2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGp3ay5hbGcgIT09IHVuZGVmaW5lZCAmJiBhbGcgIT09IGp3ay5hbGcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLnVzZSAhPT0gdW5kZWZpbmVkICYmIGp3ay51c2UgIT09ICdzaWcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGp3ay5rZXlfb3BzPy5pbmNsdWRlcygndmVyaWZ5JykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VTMjU2JyAmJiBqd2suY3J2ICE9PSAnUC0yNTYnOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFUzM4NCcgJiYgandrLmNydiAhPT0gJ1AtMzg0JzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRVM1MTInICYmIGp3ay5jcnYgIT09ICdQLTUyMSc6XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VkRFNBJyAmJiAhKGp3ay5jcnYgPT09ICdFZDI1NTE5JyB8fCBqd2suY3J2ID09PSAnRWQ0NDgnKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgY29uc3QgeyAwOiBqd2ssIGxlbmd0aCB9ID0gY2FuZGlkYXRlcztcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBpZiAoYWdlID49IDYwKSB7XG4gICAgICAgICAgICBqd2tzQ2FjaGUuZGVsZXRlKGFzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdlcnJvciB3aGVuIHNlbGVjdGluZyBhIEpXVCB2ZXJpZmljYXRpb24ga2V5LCBubyBhcHBsaWNhYmxlIGtleXMgZm91bmQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2Vycm9yIHdoZW4gc2VsZWN0aW5nIGEgSldUIHZlcmlmaWNhdGlvbiBrZXksIG11bHRpcGxlIGFwcGxpY2FibGUga2V5cyBmb3VuZCwgYSBcImtpZFwiIEpXVCBIZWFkZXIgUGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGltcG9ydEp3ayhhbGcsIGp3ayk7XG4gICAgaWYgKGtleS50eXBlICE9PSAncHVibGljJykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdqd2tzX3VyaSBtdXN0IG9ubHkgY29udGFpbiBwdWJsaWMga2V5cycpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufVxuZXhwb3J0IGNvbnN0IHNraXBTdWJqZWN0Q2hlY2sgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGdldENvbnRlbnRUeXBlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKT8uc3BsaXQoJzsnKVswXTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzVXNlckluZm9SZXNwb25zZShhcywgY2xpZW50LCBleHBlY3RlZFN1YmplY3QsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIFVzZXJJbmZvIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGxldCBqc29uO1xuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi9qd3QnKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoYXdhaXQgcmVzcG9uc2UudGV4dCgpLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy51c2VyaW5mb19zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZU9wdGlvbmFsQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVPcHRpb25hbElzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSk7XG4gICAgICAgIGpzb24gPSBjbGFpbXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2xpZW50LnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBVc2VySW5mbyBSZXNwb25zZSBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24uc3ViKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInN1YlwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwZWN0ZWRTdWJqZWN0KSB7XG4gICAgICAgIGNhc2Ugc2tpcFN1YmplY3RDaGVjazpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZFN1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJleHBlY3RlZFN1YmplY3RcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uc3ViICE9PSBleHBlY3RlZFN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIFwicmVzcG9uc2VcIiBib2R5IFwic3ViXCIgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCBtZXRob2QsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICAgIGF3YWl0IGNsaWVudEF1dGhlbnRpY2F0aW9uKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnM/LmNsaWVudFByaXZhdGVLZXkpO1xuICAgIGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICByZXR1cm4gKG9wdGlvbnM/LltleHBlcmltZW50YWxfY3VzdG9tRmV0Y2hdIHx8IGZldGNoKSh1cmwuaHJlZiwge1xuICAgICAgICBib2R5LFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgPyBzaWduYWwob3B0aW9ucy5zaWduYWwpIDogbnVsbCxcbiAgICB9KS50aGVuKHByb2Nlc3NEcG9wTm9uY2UpO1xufVxuYXN5bmMgZnVuY3Rpb24gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgZ3JhbnRUeXBlLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAndG9rZW5fZW5kcG9pbnQnLCBvcHRpb25zKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnZ3JhbnRfdHlwZScsIGdyYW50VHlwZSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMuRFBvUCwgdXJsLCAnUE9TVCcsIGdldENsb2NrU2tldyhjbGllbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBwYXJhbWV0ZXJzLCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoVG9rZW5HcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgcmVmcmVzaFRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcocmVmcmVzaFRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlZnJlc2hUb2tlblwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgncmVmcmVzaF90b2tlbicsIHJlZnJlc2hUb2tlbik7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICdyZWZyZXNoX3Rva2VuJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5jb25zdCBpZFRva2VuQ2xhaW1zID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zKHJlZikge1xuICAgIGlmICghcmVmLmlkX3Rva2VuKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNsYWltcyA9IGlkVG9rZW5DbGFpbXMuZ2V0KHJlZik7XG4gICAgaWYgKCFjbGFpbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZWZcIiB3YXMgYWxyZWFkeSBnYXJiYWdlIGNvbGxlY3RlZCBvciBkaWQgbm90IHJlc29sdmUgZnJvbSB0aGUgcHJvcGVyIHNvdXJjZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYWltcztcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgaWdub3JlSWRUb2tlbiA9IGZhbHNlLCBpZ25vcmVSZWZyZXNoVG9rZW4gPSBmYWxzZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gVG9rZW4gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLmFjY2Vzc190b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJhY2Nlc3NfdG9rZW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24udG9rZW5fdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ0b2tlbl90eXBlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAganNvbi50b2tlbl90eXBlID0ganNvbi50b2tlbl90eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGpzb24udG9rZW5fdHlwZSAhPT0gJ2Rwb3AnICYmIGpzb24udG9rZW5fdHlwZSAhPT0gJ2JlYXJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIGB0b2tlbl90eXBlYCB2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAoanNvbi5leHBpcmVzX2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInIHx8IGpzb24uZXhwaXJlc19pbiA8PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmICghaWdub3JlUmVmcmVzaFRva2VuICYmXG4gICAgICAgIGpzb24ucmVmcmVzaF90b2tlbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF2YWxpZGF0ZVN0cmluZyhqc29uLnJlZnJlc2hfdG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwicmVmcmVzaF90b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChqc29uLnNjb3BlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uc2NvcGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwic2NvcGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghaWdub3JlSWRUb2tlbikge1xuICAgICAgICBpZiAoanNvbi5pZF90b2tlbiAhPT0gdW5kZWZpbmVkICYmICF2YWxpZGF0ZVN0cmluZyhqc29uLmlkX3Rva2VuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpZF90b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24uaWRfdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChqc29uLmlkX3Rva2VuLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy5pZF90b2tlbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnZXhwJywgJ2lhdCcsICdpc3MnLCAnc3ViJ10pKVxuICAgICAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNsYWltcy5hdWQpICYmIGNsYWltcy5hdWQubGVuZ3RoICE9PSAxICYmIGNsYWltcy5henAgIT09IGNsaWVudC5jbGllbnRfaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwiYXpwXCIgKGF1dGhvcml6ZWQgcGFydHkpIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpZW50LnJlcXVpcmVfYXV0aF90aW1lICYmIHR5cGVvZiBjbGFpbXMuYXV0aF90aW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJhdXRoX3RpbWVcIiAoYXV0aGVudGljYXRpb24gdGltZSkgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMuc2V0KGpzb24sIGNsYWltcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1JlZnJlc2hUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsQXVkaWVuY2UoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuY2xhaW1zLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUF1ZGllbmNlKGV4cGVjdGVkLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBdWRpZW5jZShleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0LmNsYWltcy5hdWQpKSB7XG4gICAgICAgIGlmICghcmVzdWx0LmNsYWltcy5hdWQuaW5jbHVkZXMoZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQuY2xhaW1zLmF1ZCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsSXNzdWVyKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmNsYWltcy5pc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVJc3N1ZXIoZXhwZWN0ZWQsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUlzc3VlcihleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5jbGFpbXMuaXNzICE9PSBleHBlY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlzc1wiIChpc3N1ZXIpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBicmFuZGVkID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGJyYW5kKHNlYXJjaFBhcmFtcykge1xuICAgIGJyYW5kZWQuYWRkKHNlYXJjaFBhcmFtcyk7XG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRob3JpemF0aW9uQ29kZUdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjYWxsYmFja1BhcmFtZXRlcnMsIHJlZGlyZWN0VXJpLCBjb2RlVmVyaWZpZXIsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFicmFuZGVkLmhhcyhjYWxsYmFja1BhcmFtZXRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tQYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMgb2J0YWluZWQgZnJvbSBcInZhbGlkYXRlQXV0aFJlc3BvbnNlKClcIiwgb3IgXCJ2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSgpJyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcocmVkaXJlY3RVcmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVkaXJlY3RVcmlcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNvZGVWZXJpZmllcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjb2RlVmVyaWZpZXJcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKGNhbGxiYWNrUGFyYW1ldGVycywgJ2NvZGUnKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnbm8gYXV0aG9yaXphdGlvbiBjb2RlIGluIFwiY2FsbGJhY2tQYXJhbWV0ZXJzXCInKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdyZWRpcmVjdF91cmknLCByZWRpcmVjdFVyaSk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2NvZGVfdmVyaWZpZXInLCBjb2RlVmVyaWZpZXIpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdjb2RlJywgY29kZSk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICdhdXRob3JpemF0aW9uX2NvZGUnLCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbn1cbmNvbnN0IGp3dENsYWltTmFtZXMgPSB7XG4gICAgYXVkOiAnYXVkaWVuY2UnLFxuICAgIGNfaGFzaDogJ2NvZGUgaGFzaCcsXG4gICAgY2xpZW50X2lkOiAnY2xpZW50IGlkJyxcbiAgICBleHA6ICdleHBpcmF0aW9uIHRpbWUnLFxuICAgIGlhdDogJ2lzc3VlZCBhdCcsXG4gICAgaXNzOiAnaXNzdWVyJyxcbiAgICBqdGk6ICdqd3QgaWQnLFxuICAgIG5vbmNlOiAnbm9uY2UnLFxuICAgIHNfaGFzaDogJ3N0YXRlIGhhc2gnLFxuICAgIHN1YjogJ3N1YmplY3QnLFxuICAgIGF0aDogJ2FjY2VzcyB0b2tlbiBoYXNoJyxcbiAgICBodG06ICdodHRwIG1ldGhvZCcsXG4gICAgaHR1OiAnaHR0cCB1cmknLFxuICAgIGNuZjogJ2NvbmZpcm1hdGlvbicsXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVQcmVzZW5jZShyZXF1aXJlZCwgcmVzdWx0KSB7XG4gICAgZm9yIChjb25zdCBjbGFpbSBvZiByZXF1aXJlZCkge1xuICAgICAgICBpZiAocmVzdWx0LmNsYWltc1tjbGFpbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRShgSldUIFwiJHtjbGFpbX1cIiAoJHtqd3RDbGFpbU5hbWVzW2NsYWltXX0pIGNsYWltIG1pc3NpbmdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNvbnN0IGV4cGVjdE5vTm9uY2UgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBza2lwQXV0aFRpbWVDaGVjayA9IFN5bWJvbCgpO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9wZW5JRFJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBleHBlY3RlZE5vbmNlLCBtYXhBZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpO1xuICAgIGlmIChpc09BdXRoMkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhyZXN1bHQuaWRfdG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaWRfdG9rZW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBtYXhBZ2UgPz8gKG1heEFnZSA9IGNsaWVudC5kZWZhdWx0X21heF9hZ2UgPz8gc2tpcEF1dGhUaW1lQ2hlY2spO1xuICAgIGNvbnN0IGNsYWltcyA9IGdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMocmVzdWx0KTtcbiAgICBpZiAoKGNsaWVudC5yZXF1aXJlX2F1dGhfdGltZSB8fCBtYXhBZ2UgIT09IHNraXBBdXRoVGltZUNoZWNrKSAmJlxuICAgICAgICBjbGFpbXMuYXV0aF90aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSUQgVG9rZW4gXCJhdXRoX3RpbWVcIiAoYXV0aGVudGljYXRpb24gdGltZSkgY2xhaW0gbWlzc2luZycpO1xuICAgIH1cbiAgICBpZiAobWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykge1xuICAgICAgICBpZiAodHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicgfHwgbWF4QWdlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLm1heF9hZ2VcIiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCk7XG4gICAgICAgIGlmIChjbGFpbXMuYXV0aF90aW1lICsgbWF4QWdlIDwgbm93IC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd0b28gbXVjaCB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IEVuZC1Vc2VyIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChleHBlY3RlZE5vbmNlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlIGV4cGVjdE5vTm9uY2U6XG4gICAgICAgICAgICBpZiAoY2xhaW1zLm5vbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwibm9uY2VcIiBjbGFpbSB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGV4cGVjdGVkTm9uY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHBlY3RlZE5vbmNlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGFpbXMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0lEIFRva2VuIFwibm9uY2VcIiBjbGFpbSBtaXNzaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xhaW1zLm5vbmNlICE9PSBleHBlY3RlZE5vbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPQXV0aDJSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgdHJ1ZSk7XG4gICAgaWYgKGlzT0F1dGgyRXJyb3IocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmlkX3Rva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuaWRfdG9rZW4gPT09ICdzdHJpbmcnICYmIHJlc3VsdC5pZF90b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1VuZXhwZWN0ZWQgSUQgVG9rZW4gcmV0dXJuZWQsIHVzZSBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZSgpIGZvciBPcGVuSUQgQ29ubmVjdCBjYWxsYmFjayBwcm9jZXNzaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHJlc3VsdC5pZF90b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNoZWNrSnd0VHlwZShleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQuaGVhZGVyLnR5cCAhPT0gJ3N0cmluZycgfHwgbm9ybWFsaXplVHlwKHJlc3VsdC5oZWFkZXIudHlwKSAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJ0eXBcIiBoZWFkZXIgcGFyYW1ldGVyIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xpZW50Q3JlZGVudGlhbHNHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgJ2NsaWVudF9jcmVkZW50aWFscycsIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyksIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDbGllbnRDcmVkZW50aWFsc1Jlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCB0cnVlLCB0cnVlKTtcbiAgICBpZiAoaXNPQXV0aDJFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV2b2NhdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgdG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyh0b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0b2tlblwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ3Jldm9jYXRpb25fZW5kcG9pbnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLmRlbGV0ZSgnYWNjZXB0Jyk7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKChlcnIgPSBhd2FpdCBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIFJldm9jYXRpb24gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIGJvZHkgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGludHJvc3BlY3Rpb25SZXF1ZXN0KGFzLCBjbGllbnQsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcodG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widG9rZW5cIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdpbnRyb3NwZWN0aW9uX2VuZHBvaW50Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCd0b2tlbicsIHRva2VuKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaWYgKG9wdGlvbnM/LnJlcXVlc3RKd3RSZXNwb25zZSA/PyBjbGllbnQuaW50cm9zcGVjdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vdG9rZW4taW50cm9zcGVjdGlvbitqd3QnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJbnRyb3NwZWN0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKChlcnIgPSBhd2FpdCBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIEludHJvc3BlY3Rpb24gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgbGV0IGpzb247XG4gICAgaWYgKGdldENvbnRlbnRUeXBlKHJlc3BvbnNlKSA9PT0gJ2FwcGxpY2F0aW9uL3Rva2VuLWludHJvc3BlY3Rpb24rand0Jykge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgeyBjbGFpbXMgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGF3YWl0IHJlc3BvbnNlLnRleHQoKSwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuaW50cm9zcGVjdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy5pbnRyb3NwZWN0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQpLCBub1NpZ25hdHVyZUNoZWNrLCBnZXRDbG9ja1NrZXcoY2xpZW50KSwgZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KSlcbiAgICAgICAgICAgIC50aGVuKGNoZWNrSnd0VHlwZS5iaW5kKHVuZGVmaW5lZCwgJ3Rva2VuLWludHJvc3BlY3Rpb24rand0JykpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBbJ2F1ZCcsICdpYXQnLCAnaXNzJ10pKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzLmlzc3VlcikpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgICAgIGpzb24gPSBjbGFpbXMudG9rZW5faW50cm9zcGVjdGlvbjtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBcInRva2VuX2ludHJvc3BlY3Rpb25cIiBjbGFpbSBtdXN0IGJlIGEgSlNPTiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbi5hY3RpdmUgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImFjdGl2ZVwiIHByb3BlcnR5IG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gandrc1JlcXVlc3QoYXMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAnandrc191cmknKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaGVhZGVycy5hcHBlbmQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qd2stc2V0K2pzb24nKTtcbiAgICByZXR1cm4gKG9wdGlvbnM/LltleHBlcmltZW50YWxfY3VzdG9tRmV0Y2hdIHx8IGZldGNoKSh1cmwuaHJlZiwge1xuICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NKd2tzUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBKU09OIFdlYiBLZXkgU2V0IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLmtleXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwia2V5c1wiIHByb3BlcnR5IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5wcm90b3R5cGUuZXZlcnkuY2FsbChqc29uLmtleXMsIGlzSnNvbk9iamVjdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJrZXlzXCIgcHJvcGVydHkgbWVtYmVycyBtdXN0IGJlIEpXSyBmb3JtYXR0ZWQgb2JqZWN0cycpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+IDM5OSAmJiByZXNwb25zZS5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKGlzSnNvbk9iamVjdChqc29uKSAmJiB0eXBlb2YganNvbi5lcnJvciA9PT0gJ3N0cmluZycgJiYganNvbi5lcnJvci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5lcnJvcl9kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLmVycm9yX2Rlc2NyaXB0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvbi5lcnJvcl9kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uZXJyb3JfdXJpICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uZXJyb3JfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvbi5lcnJvcl91cmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc29uLmFsZ3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5hbGdzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvbi5hbGdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNvbi5zY29wZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLnNjb3BlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvbi5zY29wZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjaGVja1N1cHBvcnRlZEp3c0FsZyhhbGcpIHtcbiAgICBpZiAoIVNVUFBPUlRFRF9KV1NfQUxHUy5pbmNsdWRlcyhhbGcpKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBKV1MgXCJhbGdcIiBpZGVudGlmaWVyJyk7XG4gICAgfVxuICAgIHJldHVybiBhbGc7XG59XG5mdW5jdGlvbiBjaGVja1JzYUtleUFsZ29yaXRobShhbGdvcml0aG0pIHtcbiAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA8IDIwNDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRShgJHthbGdvcml0aG0ubmFtZX0gbW9kdWx1c0xlbmd0aCBtdXN0IGJlIGF0IGxlYXN0IDIwNDggYml0c2ApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVjZHNhSGFzaE5hbWUobmFtZWRDdXJ2ZSkge1xuICAgIHN3aXRjaCAobmFtZWRDdXJ2ZSkge1xuICAgICAgICBjYXNlICdQLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ1NIQS0yNTYnO1xuICAgICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ1NIQS0zODQnO1xuICAgICAgICBjYXNlICdQLTUyMSc6XG4gICAgICAgICAgICByZXR1cm4gJ1NIQS01MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXlUb1N1YnRsZShrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubmFtZSkge1xuICAgICAgICBjYXNlICdFQ0RTQSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGtleS5hbGdvcml0aG0ubmFtZSxcbiAgICAgICAgICAgICAgICBoYXNoOiBlY2RzYUhhc2hOYW1lKGtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdSU0EtUFNTJzoge1xuICAgICAgICAgICAgY2hlY2tSc2FLZXlBbGdvcml0aG0oa2V5LmFsZ29yaXRobSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0uaGFzaC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTI1Nic6XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTUxMic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXkuYWxnb3JpdGhtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWx0TGVuZ3RoOiBwYXJzZUludChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5zbGljZSgtMyksIDEwKSA+PiAzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnUlNBU1NBLVBLQ1MxLXYxXzUnOlxuICAgICAgICAgICAgY2hlY2tSc2FLZXlBbGdvcml0aG0oa2V5LmFsZ29yaXRobSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5LmFsZ29yaXRobS5uYW1lO1xuICAgICAgICBjYXNlICdFZDQ0OCc6XG4gICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICAgICAgcmV0dXJuIGtleS5hbGdvcml0aG0ubmFtZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbn1cbmNvbnN0IG5vU2lnbmF0dXJlQ2hlY2sgPSBTeW1ib2woKTtcbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSnd0KGp3cywgY2hlY2tBbGcsIGdldEtleSwgY2xvY2tTa2V3LCBjbG9ja1RvbGVyYW5jZSkge1xuICAgIGNvbnN0IHsgMDogcHJvdGVjdGVkSGVhZGVyLCAxOiBwYXlsb2FkLCAyOiBlbmNvZGVkU2lnbmF0dXJlLCBsZW5ndGggfSA9IGp3cy5zcGxpdCgnLicpO1xuICAgIGlmIChsZW5ndGggPT09IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ0pXRSBzdHJ1Y3R1cmUgSldUcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0ludmFsaWQgSldUJyk7XG4gICAgfVxuICAgIGxldCBoZWFkZXI7XG4gICAgdHJ5IHtcbiAgICAgICAgaGVhZGVyID0gSlNPTi5wYXJzZShidWYoYjY0dShwcm90ZWN0ZWRIZWFkZXIpKSk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgSldUIEhlYWRlciBib2R5IGFzIGJhc2U2NHVybCBlbmNvZGVkIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChoZWFkZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBIZWFkZXIgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgY2hlY2tBbGcoaGVhZGVyKTtcbiAgICBpZiAoaGVhZGVyLmNyaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImNyaXRcIiBoZWFkZXIgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGI2NHUoZW5jb2RlZFNpZ25hdHVyZSk7XG4gICAgbGV0IGtleTtcbiAgICBpZiAoZ2V0S2V5ICE9PSBub1NpZ25hdHVyZUNoZWNrKSB7XG4gICAgICAgIGtleSA9IGF3YWl0IGdldEtleShoZWFkZXIpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IGAke3Byb3RlY3RlZEhlYWRlcn0uJHtwYXlsb2FkfWA7XG4gICAgICAgIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoa2V5VG9TdWJ0bGUoa2V5KSwga2V5LCBzaWduYXR1cmUsIGJ1ZihpbnB1dCkpO1xuICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1Qgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2xhaW1zO1xuICAgIHRyeSB7XG4gICAgICAgIGNsYWltcyA9IEpTT04ucGFyc2UoYnVmKGI2NHUocGF5bG9hZCkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBKV1QgUGF5bG9hZCBib2R5IGFzIGJhc2U2NHVybCBlbmNvZGVkIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChjbGFpbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBQYXlsb2FkIG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGlmIChjbGFpbXMuZXhwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuZXhwICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5leHAgPD0gbm93IC0gY2xvY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiZXhwXCIgKGV4cGlyYXRpb24gdGltZSkgY2xhaW0gdmFsdWUsIHRpbWVzdGFtcCBpcyA8PSBub3coKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuaWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuaWF0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpYXRcIiAoaXNzdWVkIGF0KSBjbGFpbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5pc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5pc3MgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlzc1wiIChpc3N1ZXIpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLm5iZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLm5iZiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwibmJmXCIgKG5vdCBiZWZvcmUpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLm5iZiA+IG5vdyArIGNsb2NrVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcIm5iZlwiIChub3QgYmVmb3JlKSBjbGFpbSB2YWx1ZSwgdGltZXN0YW1wIGlzID4gbm93KCknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmF1ZCAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoY2xhaW1zLmF1ZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYXVkXCIgKGF1ZGllbmNlKSBjbGFpbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaGVhZGVyLCBjbGFpbXMsIHNpZ25hdHVyZSwga2V5IH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgZXhwZWN0ZWRTdGF0ZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5zZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGlmICghKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zLCBvciBVUkwnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3Jlc3BvbnNlJyk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInBhcmFtZXRlcnNcIiBkb2VzIG5vdCBjb250YWluIGEgSkFSTSByZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFzLmp3a3NfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmp3a3NfdXJpXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QocmVzcG9uc2UsIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmF1dGhvcml6YXRpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuYXV0aG9yaXphdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkuYmluZCh1bmRlZmluZWQsIGFzLCBvcHRpb25zKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnYXVkJywgJ2V4cCcsICdpc3MnXSkpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNsYWltcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYga2V5ICE9PSAnYXVkJykge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVBdXRoUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzdWx0LCBleHBlY3RlZFN0YXRlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlkVG9rZW5IYXNoKGFsZywgZGF0YSwga2V5KSB7XG4gICAgbGV0IGFsZ29yaXRobTtcbiAgICBzd2l0Y2ggKGFsZykge1xuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgIGNhc2UgJ1BTMjU2JzpcbiAgICAgICAgY2FzZSAnRVMyNTYnOlxuICAgICAgICAgICAgYWxnb3JpdGhtID0gJ1NIQS0yNTYnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTMzg0JzpcbiAgICAgICAgY2FzZSAnUFMzODQnOlxuICAgICAgICBjYXNlICdFUzM4NCc6XG4gICAgICAgICAgICBhbGdvcml0aG0gPSAnU0hBLTM4NCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUlM1MTInOlxuICAgICAgICBjYXNlICdQUzUxMic6XG4gICAgICAgIGNhc2UgJ0VTNTEyJzpcbiAgICAgICAgICAgIGFsZ29yaXRobSA9ICdTSEEtNTEyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFZERTQSc6XG4gICAgICAgICAgICBpZiAoa2V5LmFsZ29yaXRobS5uYW1lID09PSAnRWQyNTUxOScpIHtcbiAgICAgICAgICAgICAgICBhbGdvcml0aG0gPSAnU0hBLTUxMic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3QgZGlnZXN0ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoYWxnb3JpdGhtLCBidWYoZGF0YSkpO1xuICAgIHJldHVybiBiNjR1KGRpZ2VzdC5zbGljZSgwLCBkaWdlc3QuYnl0ZUxlbmd0aCAvIDIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlkVG9rZW5IYXNoTWF0Y2hlcyhkYXRhLCBhY3R1YWwsIGFsZywga2V5KSB7XG4gICAgY29uc3QgZXhwZWN0ZWQgPSBhd2FpdCBpZFRva2VuSGFzaChhbGcsIGRhdGEsIGtleSk7XG4gICAgcmV0dXJuIGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwZXJpbWVudGFsX3ZhbGlkYXRlRGV0YWNoZWRTaWduYXR1cmVSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzLmhhc2gubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInBhcmFtZXRlcnNcIiBhcyBhbiBpbnN0YW5jZSBvZiBVUkwgbXVzdCBjb250YWluIGEgaGFzaCAoZnJhZ21lbnQpIHdpdGggdGhlIEF1dGhvcml6YXRpb24gUmVzcG9uc2UgcGFyYW1ldGVycycpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMuaGFzaC5zbGljZSgxKSk7XG4gICAgfVxuICAgIGlmICghKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zJyk7XG4gICAgfVxuICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGlkX3Rva2VuID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdpZF90b2tlbicpO1xuICAgIHBhcmFtZXRlcnMuZGVsZXRlKCdpZF90b2tlbicpO1xuICAgIHN3aXRjaCAoZXhwZWN0ZWRTdGF0ZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSBleHBlY3ROb1N0YXRlOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGV4cGVjdGVkU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHBlY3RlZFN0YXRlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVBdXRoUmVzcG9uc2Uoe1xuICAgICAgICAuLi5hcyxcbiAgICAgICAgYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZDogZmFsc2UsXG4gICAgfSwgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZFN0YXRlKTtcbiAgICBpZiAoaXNPQXV0aDJFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICghaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJwYXJhbWV0ZXJzXCIgZG9lcyBub3QgY29udGFpbiBhbiBJRCBUb2tlbicpO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdjb2RlJyk7XG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicGFyYW1ldGVyc1wiIGRvZXMgbm90IGNvbnRhaW4gYW4gQXV0aG9yaXphdGlvbiBDb2RlJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXMuandrc191cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMuandrc191cmlcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVpcmVkQ2xhaW1zID0gW1xuICAgICAgICAnYXVkJyxcbiAgICAgICAgJ2V4cCcsXG4gICAgICAgICdpYXQnLFxuICAgICAgICAnaXNzJyxcbiAgICAgICAgJ3N1YicsXG4gICAgICAgICdub25jZScsXG4gICAgICAgICdjX2hhc2gnLFxuICAgIF07XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZFN0YXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXF1aXJlZENsYWltcy5wdXNoKCdzX2hhc2gnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbGFpbXMsIGhlYWRlciwga2V5IH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChpZF90b2tlbiwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaWRfdG9rZW5fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpLmJpbmQodW5kZWZpbmVkLCBhcywgb3B0aW9ucyksIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCByZXF1aXJlZENsYWltcykpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgY29uc3QgY2xvY2tTa2V3ID0gZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBjbG9ja1NrZXc7XG4gICAgaWYgKGNsYWltcy5pYXQgPCBub3cgLSAzNjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiaWF0XCIgKGlzc3VlZCBhdCkgY2xhaW0gdmFsdWUsIGl0IGlzIHRvbyBmYXIgaW4gdGhlIHBhc3QnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjbGFpbXMuY19oYXNoICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoYXdhaXQgaWRUb2tlbkhhc2hNYXRjaGVzKGNvZGUsIGNsYWltcy5jX2hhc2gsIGhlYWRlci5hbGcsIGtleSkpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ludmFsaWQgSUQgVG9rZW4gXCJjX2hhc2hcIiAoY29kZSBoYXNoKSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAoY2xhaW1zLnNfaGFzaCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBleHBlY3RlZFN0YXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdjb3VsZCBub3QgdmVyaWZ5IElEIFRva2VuIFwic19oYXNoXCIgKHN0YXRlIGhhc2gpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRTdGF0ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgKHR5cGVvZiBjbGFpbXMuc19oYXNoICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKGF3YWl0IGlkVG9rZW5IYXNoTWF0Y2hlcyhleHBlY3RlZFN0YXRlLCBjbGFpbXMuc19oYXNoLCBoZWFkZXIuYWxnLCBrZXkpKSAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnaW52YWxpZCBJRCBUb2tlbiBcInNfaGFzaFwiIChzdGF0ZSBoYXNoKSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50LnJlcXVpcmVfYXV0aF90aW1lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNsYWltcy5hdXRoX3RpbWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJhdXRoX3RpbWVcIiAoYXV0aGVudGljYXRpb24gdGltZSkgY2xhaW0gdmFsdWUnKTtcbiAgICB9XG4gICAgbWF4QWdlID8/IChtYXhBZ2UgPSBjbGllbnQuZGVmYXVsdF9tYXhfYWdlID8/IHNraXBBdXRoVGltZUNoZWNrKTtcbiAgICBpZiAoKGNsaWVudC5yZXF1aXJlX2F1dGhfdGltZSB8fCBtYXhBZ2UgIT09IHNraXBBdXRoVGltZUNoZWNrKSAmJlxuICAgICAgICBjbGFpbXMuYXV0aF90aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSUQgVG9rZW4gXCJhdXRoX3RpbWVcIiAoYXV0aGVudGljYXRpb24gdGltZSkgY2xhaW0gbWlzc2luZycpO1xuICAgIH1cbiAgICBpZiAobWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykge1xuICAgICAgICBpZiAodHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicgfHwgbWF4QWdlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLm1heF9hZ2VcIiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCk7XG4gICAgICAgIGlmIChjbGFpbXMuYXV0aF90aW1lICsgbWF4QWdlIDwgbm93IC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd0b28gbXVjaCB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IEVuZC1Vc2VyIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZE5vbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4cGVjdGVkTm9uY2VcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoY2xhaW1zLm5vbmNlICE9PSBleHBlY3RlZE5vbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGNsYWltcy5hdWQpICYmIGNsYWltcy5hdWQubGVuZ3RoICE9PSAxICYmIGNsYWltcy5henAgIT09IGNsaWVudC5jbGllbnRfaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcImF6cFwiIChhdXRob3JpemVkIHBhcnR5KSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hlY2tTaWduaW5nQWxnb3JpdGhtKGNsaWVudCwgaXNzdWVyLCBoZWFkZXIpIHtcbiAgICBpZiAoY2xpZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGhlYWRlci5hbGcgIT09IGNsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhbGdcIiBoZWFkZXIgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpc3N1ZXIpKSB7XG4gICAgICAgIGlmICghaXNzdWVyLmluY2x1ZGVzKGhlYWRlci5hbGcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChoZWFkZXIuYWxnICE9PSAnUlMyNTYnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCBuYW1lKSB7XG4gICAgY29uc3QgeyAwOiB2YWx1ZSwgbGVuZ3RoIH0gPSBwYXJhbWV0ZXJzLmdldEFsbChuYW1lKTtcbiAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKGBcIiR7bmFtZX1cIiBwYXJhbWV0ZXIgbXVzdCBiZSBwcm92aWRlZCBvbmx5IG9uY2VgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGNvbnN0IHNraXBTdGF0ZUNoZWNrID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgZXhwZWN0Tm9TdGF0ZSA9IFN5bWJvbCgpO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkU3RhdGUpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBpZiAoIShwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInBhcmFtZXRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTFNlYXJjaFBhcmFtcywgb3IgVVJMJyk7XG4gICAgfVxuICAgIGlmIChnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3Jlc3BvbnNlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJwYXJhbWV0ZXJzXCIgY29udGFpbnMgYSBKQVJNIHJlc3BvbnNlLCB1c2UgdmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UoKSBpbnN0ZWFkIG9mIHZhbGlkYXRlQXV0aFJlc3BvbnNlKCknKTtcbiAgICB9XG4gICAgY29uc3QgaXNzID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdpc3MnKTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnc3RhdGUnKTtcbiAgICBpZiAoIWlzcyAmJiBhcy5hdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3Jlc3BvbnNlIHBhcmFtZXRlciBcImlzc1wiIChpc3N1ZXIpIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgaWYgKGlzcyAmJiBpc3MgIT09IGFzLmlzc3Vlcikge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIFwiaXNzXCIgKGlzc3VlcikgcmVzcG9uc2UgcGFyYW1ldGVyIHZhbHVlJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwZWN0ZWRTdGF0ZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSBleHBlY3ROb1N0YXRlOlxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIFwic3RhdGVcIiByZXNwb25zZSBwYXJhbWV0ZXIgZW5jb3VudGVyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNraXBTdGF0ZUNoZWNrOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGV4cGVjdGVkU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJleHBlY3RlZFN0YXRlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgncmVzcG9uc2UgcGFyYW1ldGVyIFwic3RhdGVcIiBtaXNzaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IGV4cGVjdGVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIFwic3RhdGVcIiByZXNwb25zZSBwYXJhbWV0ZXIgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2Vycm9yJyk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGVycm9yX2Rlc2NyaXB0aW9uOiBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2Vycm9yX2Rlc2NyaXB0aW9uJyksXG4gICAgICAgICAgICBlcnJvcl91cmk6IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnZXJyb3JfdXJpJyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlkX3Rva2VuID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdpZF90b2tlbicpO1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICd0b2tlbicpO1xuICAgIGlmIChpZF90b2tlbiAhPT0gdW5kZWZpbmVkIHx8IHRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ2ltcGxpY2l0IGFuZCBoeWJyaWQgZmxvd3MgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJyYW5kKG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycykpO1xufVxuZnVuY3Rpb24gYWxnVG9TdWJ0bGUoYWxnLCBjcnYpIHtcbiAgICBzd2l0Y2ggKGFsZykge1xuICAgICAgICBjYXNlICdQUzI1Nic6XG4gICAgICAgIGNhc2UgJ1BTMzg0JzpcbiAgICAgICAgY2FzZSAnUFM1MTInOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ1JTQS1QU1MnLCBoYXNoOiBgU0hBLSR7YWxnLnNsaWNlKC0zKX1gIH07XG4gICAgICAgIGNhc2UgJ1JTMjU2JzpcbiAgICAgICAgY2FzZSAnUlMzODQnOlxuICAgICAgICBjYXNlICdSUzUxMic6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLCBoYXNoOiBgU0hBLSR7YWxnLnNsaWNlKC0zKX1gIH07XG4gICAgICAgIGNhc2UgJ0VTMjU2JzpcbiAgICAgICAgY2FzZSAnRVMzODQnOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ0VDRFNBJywgbmFtZWRDdXJ2ZTogYFAtJHthbGcuc2xpY2UoLTMpfWAgfTtcbiAgICAgICAgY2FzZSAnRVM1MTInOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ0VDRFNBJywgbmFtZWRDdXJ2ZTogJ1AtNTIxJyB9O1xuICAgICAgICBjYXNlICdFZERTQSc6IHtcbiAgICAgICAgICAgIHN3aXRjaCAoY3J2KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J2O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaW1wb3J0SndrKGFsZywgandrKSB7XG4gICAgY29uc3QgeyBleHQsIGtleV9vcHMsIHVzZSwgLi4ua2V5IH0gPSBqd2s7XG4gICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBrZXksIGFsZ1RvU3VidGxlKGFsZywgandrLmNydiksIHRydWUsIFsndmVyaWZ5J10pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldmljZUF1dGhvcml6YXRpb25SZXF1ZXN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAnZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCAnUE9TVCcsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0RldmljZUF1dGhvcml6YXRpb25SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gRGV2aWNlIEF1dGhvcml6YXRpb24gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLmRldmljZV9jb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImRldmljZV9jb2RlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnVzZXJfY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ1c2VyX2NvZGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24udmVyaWZpY2F0aW9uX3VyaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ2ZXJpZmljYXRpb25fdXJpXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInIHx8IGpzb24uZXhwaXJlc19pbiA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiZXhwaXJlc19pblwiIHByb3BlcnR5IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKGpzb24udmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF2YWxpZGF0ZVN0cmluZyhqc29uLnZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChqc29uLmludGVydmFsICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBqc29uLmludGVydmFsICE9PSAnbnVtYmVyJyB8fCBqc29uLmludGVydmFsIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaW50ZXJ2YWxcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldmljZUNvZGVHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgZGV2aWNlQ29kZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGRldmljZUNvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGV2aWNlQ29kZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnZGV2aWNlX2NvZGUnLCBkZXZpY2VDb2RlKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmRldmljZV9jb2RlJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0RldmljZUNvZGVSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIHJldHVybiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpcihhbGcsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGFsZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbGdcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBhbGdvcml0aG0gPSBhbGdUb1N1YnRsZShhbGcsIGFsZyA9PT0gJ0VkRFNBJyA/IG9wdGlvbnM/LmNydiA/PyAnRWQyNTUxOScgOiB1bmRlZmluZWQpO1xuICAgIGlmIChhbGcuc3RhcnRzV2l0aCgnUFMnKSB8fCBhbGcuc3RhcnRzV2l0aCgnUlMnKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGFsZ29yaXRobSwge1xuICAgICAgICAgICAgbW9kdWx1c0xlbmd0aDogb3B0aW9ucz8ubW9kdWx1c0xlbmd0aCA/PyAyMDQ4LFxuICAgICAgICAgICAgcHVibGljRXhwb25lbnQ6IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAwLCAweDAxXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBvcHRpb25zPy5leHRyYWN0YWJsZSA/PyBmYWxzZSwgWydzaWduJywgJ3ZlcmlmeSddKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVIdHUoaHR1KSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChodHUpO1xuICAgIHVybC5zZWFyY2ggPSAnJztcbiAgICB1cmwuaGFzaCA9ICcnO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlRFBvUChhcywgcmVxdWVzdCwgYWNjZXNzVG9rZW5DbGFpbXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXJlcXVlc3QuaGVhZGVycy5oYXMoJ2Rwb3AnKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdvcGVyYXRpb24gaW5kaWNhdGVkIERQb1AgdXNlIGJ1dCB0aGUgcmVxdWVzdCBoYXMgbm8gRFBvUCBIVFRQIEhlYWRlcicpO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2Rwb3AgJykgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoYG9wZXJhdGlvbiBpbmRpY2F0ZWQgRFBvUCB1c2UgYnV0IHRoZSByZXF1ZXN0J3MgQXV0aG9yaXphdGlvbiBIVFRQIEhlYWRlciBzY2hlbWUgaXMgbm90IERQb1BgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhY2Nlc3NUb2tlbkNsYWltcy5jbmY/LmprdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnb3BlcmF0aW9uIGluZGljYXRlZCBEUG9QIHVzZSBidXQgdGhlIEpXVCBBY2Nlc3MgVG9rZW4gaGFzIG5vIGprdCBjb25maXJtYXRpb24gY2xhaW0nKTtcbiAgICB9XG4gICAgY29uc3QgY2xvY2tTa2V3ID0gZ2V0Q2xvY2tTa2V3KG9wdGlvbnMpO1xuICAgIGNvbnN0IHByb29mID0gYXdhaXQgdmFsaWRhdGVKd3QocmVxdWVzdC5oZWFkZXJzLmdldCgnZHBvcCcpLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXM/LmRwb3Bfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCB8fCBTVVBQT1JURURfSldTX0FMR1MpLCBhc3luYyAoeyBqd2ssIGFsZyB9KSA9PiB7XG4gICAgICAgIGlmICghandrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdEUG9QIFByb29mIGlzIG1pc3NpbmcgdGhlIGp3ayBoZWFkZXIgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgaW1wb3J0SndrKGFsZywgandrKTtcbiAgICAgICAgaWYgKGtleS50eXBlICE9PSAncHVibGljJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnRFBvUCBQcm9vZiBqd2sgaGVhZGVyIHBhcmFtZXRlciBtdXN0IGNvbnRhaW4gYSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9LCBjbG9ja1NrZXcsIGdldENsb2NrVG9sZXJhbmNlKG9wdGlvbnMpKVxuICAgICAgICAudGhlbihjaGVja0p3dFR5cGUuYmluZCh1bmRlZmluZWQsICdkcG9wK2p3dCcpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBbJ2lhdCcsICdqdGknLCAnYXRoJywgJ2h0bScsICdodHUnXSkpO1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhub3cgLSBwcm9vZi5jbGFpbXMuaWF0KTtcbiAgICBpZiAoZGlmZiA+IDMwMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdEUG9QIFByb29mIGlhdCBpcyBub3QgcmVjZW50IGVub3VnaCcpO1xuICAgIH1cbiAgICBpZiAocHJvb2YuY2xhaW1zLmh0bSAhPT0gcmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnRFBvUCBQcm9vZiBodG0gbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9vZi5jbGFpbXMuaHR1ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICBub3JtYWxpemVIdHUocHJvb2YuY2xhaW1zLmh0dSkgIT09IG5vcm1hbGl6ZUh0dShyZXF1ZXN0LnVybCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnRFBvUCBQcm9vZiBodHUgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKS5zcGxpdCgnICcpWzFdO1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVyLmVuY29kZShhY2Nlc3NUb2tlbikpKTtcbiAgICAgICAgaWYgKHByb29mLmNsYWltcy5hdGggIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdEUG9QIFByb29mIGF0aCBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudHM7XG4gICAgICAgIHN3aXRjaCAocHJvb2YuaGVhZGVyLmp3ay5rdHkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VDJzpcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjcnY6IHByb29mLmhlYWRlci5qd2suY3J2LFxuICAgICAgICAgICAgICAgICAgICBrdHk6IHByb29mLmhlYWRlci5qd2sua3R5LFxuICAgICAgICAgICAgICAgICAgICB4OiBwcm9vZi5oZWFkZXIuandrLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHByb29mLmhlYWRlci5qd2sueSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnT0tQJzpcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjcnY6IHByb29mLmhlYWRlci5qd2suY3J2LFxuICAgICAgICAgICAgICAgICAgICBrdHk6IHByb29mLmhlYWRlci5qd2sua3R5LFxuICAgICAgICAgICAgICAgICAgICB4OiBwcm9vZi5oZWFkZXIuandrLngsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JTQSc6XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZTogcHJvb2YuaGVhZGVyLmp3ay5lLFxuICAgICAgICAgICAgICAgICAgICBrdHk6IHByb29mLmhlYWRlci5qd2sua3R5LFxuICAgICAgICAgICAgICAgICAgICBuOiBwcm9vZi5oZWFkZXIuandrLm4sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBlY3RlZCA9IGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShjb21wb25lbnRzKSkpKTtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuQ2xhaW1zLmNuZi5qa3QgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgQWNjZXNzIFRva2VuIGNvbmZpcm1hdGlvbiBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cGVyaW1lbnRhbF92YWxpZGF0ZUp3dEFjY2Vzc1Rva2VuKGFzLCByZXF1ZXN0LCBleHBlY3RlZEF1ZGllbmNlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlcXVlc3QsIFJlcXVlc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVxdWVzdFwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVxdWVzdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGV4cGVjdGVkQXVkaWVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wiZXhwZWN0ZWRBdWRpZW5jZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdhdXRob3JpemF0aW9uJyk7XG4gICAgaWYgKCFhdXRob3JpemF0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVxdWVzdFwiIGlzIG1pc3NpbmcgYW4gQXV0aG9yaXphdGlvbiBIVFRQIEhlYWRlcicpO1xuICAgIH1cbiAgICBsZXQgeyAwOiBzY2hlbWUsIDE6IGFjY2Vzc1Rva2VuLCBsZW5ndGggfSA9IGF1dGhvcml6YXRpb24uc3BsaXQoJyAnKTtcbiAgICBzY2hlbWUgPSBzY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgICAgICBjYXNlICdkcG9wJzpcbiAgICAgICAgY2FzZSAnYmVhcmVyJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEF1dGhvcml6YXRpb24gSFRUUCBIZWFkZXIgc2NoZW1lJyk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnaW52YWxpZCBBdXRob3JpemF0aW9uIEhUVFAgSGVhZGVyIGZvcm1hdCcpO1xuICAgIH1cbiAgICBjb25zdCByZXF1aXJlZENsYWltcyA9IFtcbiAgICAgICAgJ2lzcycsXG4gICAgICAgICdleHAnLFxuICAgICAgICAnYXVkJyxcbiAgICAgICAgJ3N1YicsXG4gICAgICAgICdpYXQnLFxuICAgICAgICAnanRpJyxcbiAgICAgICAgJ2NsaWVudF9pZCcsXG4gICAgXTtcbiAgICBpZiAob3B0aW9ucz8ucmVxdWlyZURQb1AgfHwgc2NoZW1lID09PSAnZHBvcCcgfHwgcmVxdWVzdC5oZWFkZXJzLmhhcygnZHBvcCcpKSB7XG4gICAgICAgIHJlcXVpcmVkQ2xhaW1zLnB1c2goJ2NuZicpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoYWNjZXNzVG9rZW4sIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTVVBQT1JURURfSldTX0FMR1MpLCBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaS5iaW5kKHVuZGVmaW5lZCwgYXMsIG9wdGlvbnMpLCBnZXRDbG9ja1NrZXcob3B0aW9ucyksIGdldENsb2NrVG9sZXJhbmNlKG9wdGlvbnMpKVxuICAgICAgICAudGhlbihjaGVja0p3dFR5cGUuYmluZCh1bmRlZmluZWQsICdhdCtqd3QnKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgcmVxdWlyZWRDbGFpbXMpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgZXhwZWN0ZWRBdWRpZW5jZSkpO1xuICAgIGZvciAoY29uc3QgY2xhaW0gb2YgWydjbGllbnRfaWQnLCAnanRpJywgJ3N1YiddKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zW2NsYWltXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoYHVuZXhwZWN0ZWQgSldUIFwiJHtjbGFpbX1cIiBjbGFpbSB0eXBlYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdjbmYnIGluIGNsYWltcykge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChjbGFpbXMuY25mKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJjbmZcIiAoY29uZmlybWF0aW9uKSBjbGFpbSB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgMDogY25mLCBsZW5ndGggfSA9IE9iamVjdC5rZXlzKGNsYWltcy5jbmYpO1xuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ211bHRpcGxlIGNvbmZpcm1hdGlvbiBjbGFpbXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbmYgIT09ICdqa3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXVCBDb25maXJtYXRpb24gbWV0aG9kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnJlcXVpcmVEUG9QIHx8XG4gICAgICAgIHNjaGVtZSA9PT0gJ2Rwb3AnIHx8XG4gICAgICAgIGNsYWltcy5jbmY/LmprdCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5oYXMoJ2Rwb3AnKSkge1xuICAgICAgICBhd2FpdCB2YWxpZGF0ZURQb1AoYXMsIHJlcXVlc3QsIGNsYWltcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFpbXM7XG59XG4iXSwibmFtZXMiOlsiVVNFUl9BR0VOVCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInN0YXJ0c1dpdGgiLCJOQU1FIiwiVkVSU0lPTiIsImxvb3NlSW5zdGFuY2VPZiIsImlucHV0IiwiZXhwZWN0ZWQiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwicHJvdG90eXBlIiwiY2xvY2tTa2V3IiwiY2xvY2tUb2xlcmFuY2UiLCJleHBlcmltZW50YWxfY3VzdG9tRmV0Y2giLCJleHBlcmltZW50YWxDdXN0b21GZXRjaCIsImV4cGVyaW1lbnRhbF91c2VNdGxzQWxpYXMiLCJleHBlcmltZW50YWxVc2VNdGxzQWxpYXMiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWYiLCJlbmNvZGUiLCJkZWNvZGUiLCJDSFVOS19TSVpFIiwiZW5jb2RlQmFzZTY0VXJsIiwiQXJyYXlCdWZmZXIiLCJVaW50OEFycmF5IiwiYXJyIiwiaSIsImJ5dGVMZW5ndGgiLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJzdWJhcnJheSIsImJ0b2EiLCJqb2luIiwicmVwbGFjZSIsImRlY29kZUJhc2U2NFVybCIsImJpbmFyeSIsImF0b2IiLCJieXRlcyIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjYXVzZSIsIk9QRSIsImI2NHUiLCJMUlUiLCJjb25zdHJ1Y3RvciIsIm1heFNpemUiLCJjYWNoZSIsIk1hcCIsIl9jYWNoZSIsImdldCIsImtleSIsInYiLCJ1cGRhdGUiLCJ1bmRlZmluZWQiLCJoYXMiLCJzZXQiLCJ2YWx1ZSIsImRlbGV0ZSIsInNpemUiLCJVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiT3BlcmF0aW9uUHJvY2Vzc2luZ0Vycm9yIiwib3B0aW9ucyIsImRwb3BOb25jZXMiLCJpc0NyeXB0b0tleSIsIkNyeXB0b0tleSIsImlzUHJpdmF0ZUtleSIsInR5cGUiLCJpc1B1YmxpY0tleSIsIlNVUFBPUlRFRF9KV1NfQUxHUyIsInByb2Nlc3NEcG9wTm9uY2UiLCJyZXNwb25zZSIsImhlYWRlcnMiLCJ1cmwiLCJVUkwiLCJvcmlnaW4iLCJub3JtYWxpemVUeXAiLCJ0b0xvd2VyQ2FzZSIsImlzSnNvbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInByZXBhcmVIZWFkZXJzIiwiSGVhZGVycyIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIlR5cGVFcnJvciIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwiZGlzY292ZXJ5UmVxdWVzdCIsImlzc3VlcklkZW50aWZpZXIiLCJwcm90b2NvbCIsImhyZWYiLCJhbGdvcml0aG0iLCJwYXRobmFtZSIsImZldGNoIiwibWV0aG9kIiwicmVkaXJlY3QiLCJ0aGVuIiwidmFsaWRhdGVTdHJpbmciLCJwcm9jZXNzRGlzY292ZXJ5UmVzcG9uc2UiLCJleHBlY3RlZElzc3VlcklkZW50aWZpZXIiLCJSZXNwb25zZSIsInN0YXR1cyIsImFzc2VydFJlYWRhYmxlUmVzcG9uc2UiLCJqc29uIiwiaXNzdWVyIiwicmFuZG9tQnl0ZXMiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJnZW5lcmF0ZVJhbmRvbUNvZGVWZXJpZmllciIsImdlbmVyYXRlUmFuZG9tU3RhdGUiLCJnZW5lcmF0ZVJhbmRvbU5vbmNlIiwiY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UiLCJjb2RlVmVyaWZpZXIiLCJzdWJ0bGUiLCJkaWdlc3QiLCJnZXRLZXlBbmRLaWQiLCJraWQiLCJmb3JtVXJsRW5jb2RlIiwidG9rZW4iLCJlbmNvZGVVUklDb21wb25lbnQiLCJjbGllbnRTZWNyZXRCYXNpYyIsImNsaWVudElkIiwiY2xpZW50U2VjcmV0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImNyZWRlbnRpYWxzIiwicHNBbGciLCJoYXNoIiwicnNBbGciLCJlc0FsZyIsIm5hbWVkQ3VydmUiLCJrZXlUb0p3cyIsImdldENsb2NrU2tldyIsImNsaWVudCIsIk51bWJlciIsImlzRmluaXRlIiwiZ2V0Q2xvY2tUb2xlcmFuY2UiLCJ0b2xlcmFuY2UiLCJNYXRoIiwic2lnbiIsImVwb2NoVGltZSIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImNsaWVudEFzc2VydGlvbiIsImFzIiwianRpIiwiYXVkIiwidG9rZW5fZW5kcG9pbnQiLCJleHAiLCJpYXQiLCJuYmYiLCJpc3MiLCJjbGllbnRfaWQiLCJzdWIiLCJwcml2YXRlS2V5Snd0Iiwiand0IiwiYWxnIiwiYXNzZXJ0QXMiLCJhc3NlcnRDbGllbnQiLCJhc3NlcnRDbGllbnRTZWNyZXQiLCJhc3NlcnROb0NsaWVudFByaXZhdGVLZXkiLCJjbGllbnRBdXRoTWV0aG9kIiwiY2xpZW50UHJpdmF0ZUtleSIsImFzc2VydE5vQ2xpZW50U2VjcmV0IiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJib2R5IiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QiLCJjbGllbnRfc2VjcmV0IiwiaGVhZGVyIiwiY2xhaW1zU2V0IiwidXNhZ2VzIiwiaW5jbHVkZXMiLCJKU09OIiwic3RyaW5naWZ5Iiwic2lnbmF0dXJlIiwia2V5VG9TdWJ0bGUiLCJpc3N1ZVJlcXVlc3RPYmplY3QiLCJwYXJhbWV0ZXJzIiwicHJpdmF0ZUtleSIsIlVSTFNlYXJjaFBhcmFtcyIsImNsYWltcyIsInJlc291cmNlIiwiZ2V0QWxsIiwicGFyc2UiLCJ0eXAiLCJkcG9wUHJvb2ZKd3QiLCJodG0iLCJhY2Nlc3NUb2tlbiIsInB1YmxpY0tleSIsIm5vbmNlIiwiZXh0cmFjdGFibGUiLCJwcm9vZiIsImp3ayIsInB1YmxpY0p3ayIsImh0dSIsImF0aCIsImp3a0NhY2hlIiwiV2Vha01hcCIsImt0eSIsImUiLCJuIiwieCIsInkiLCJjcnYiLCJleHBvcnRLZXkiLCJ2YWxpZGF0ZUVuZHBvaW50IiwiZW5kcG9pbnQiLCJyZXNvbHZlRW5kcG9pbnQiLCJtdGxzX2VuZHBvaW50X2FsaWFzZXMiLCJwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdCIsIkRQb1AiLCJhdXRoZW50aWNhdGVkUmVxdWVzdCIsImlzT0F1dGgyRXJyb3IiLCJlcnJvciIsInVucXVvdGUiLCJzbGljZSIsIlNQTElUX1JFR0VYUCIsIlNDSEVNRVNfUkVHRVhQIiwid3d3QXV0aCIsInNjaGVtZSIsInBhcmFtcyIsInNwbGl0IiwiaWR4IiwicGFyc2VXd3dBdXRoZW50aWNhdGVDaGFsbGVuZ2VzIiwicmVzdWx0IiwiaW5kZXgiLCJtYXRjaEFsbCIsImNoYWxsZW5nZXMiLCJtYXAiLCJpbmRleE9mIiwib3RoZXJzIiwibmV4dCIsInByb2Nlc3NQdXNoZWRBdXRob3JpemF0aW9uUmVzcG9uc2UiLCJlcnIiLCJoYW5kbGVPQXV0aEJvZHlFcnJvciIsInJlcXVlc3RfdXJpIiwiZXhwaXJlc19pbiIsInByb3RlY3RlZFJlc291cmNlUmVxdWVzdCIsInVzZXJJbmZvUmVxdWVzdCIsInVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGciLCJhcHBlbmQiLCJqd2tzQ2FjaGUiLCJnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaSIsImNoZWNrU3VwcG9ydGVkSndzQWxnIiwiandrcyIsImFnZSIsImp3a3NSZXF1ZXN0IiwicHJvY2Vzc0p3a3NSZXNwb25zZSIsImNhbmRpZGF0ZXMiLCJrZXlzIiwiZmlsdGVyIiwidXNlIiwia2V5X29wcyIsImltcG9ydEp3ayIsInNraXBTdWJqZWN0Q2hlY2siLCJnZXRDb250ZW50VHlwZSIsInByb2Nlc3NVc2VySW5mb1Jlc3BvbnNlIiwiZXhwZWN0ZWRTdWJqZWN0IiwidmFsaWRhdGVKd3QiLCJ0ZXh0IiwiY2hlY2tTaWduaW5nQWxnb3JpdGhtIiwiYmluZCIsInVzZXJpbmZvX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJub1NpZ25hdHVyZUNoZWNrIiwidmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlIiwidmFsaWRhdGVPcHRpb25hbElzc3VlciIsInRva2VuRW5kcG9pbnRSZXF1ZXN0IiwiZ3JhbnRUeXBlIiwicmVmcmVzaFRva2VuR3JhbnRSZXF1ZXN0IiwicmVmcmVzaFRva2VuIiwiYWRkaXRpb25hbFBhcmFtZXRlcnMiLCJpZFRva2VuQ2xhaW1zIiwiZ2V0VmFsaWRhdGVkSWRUb2tlbkNsYWltcyIsInJlZiIsImlkX3Rva2VuIiwicHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlIiwiaWdub3JlSWRUb2tlbiIsImlnbm9yZVJlZnJlc2hUb2tlbiIsImFjY2Vzc190b2tlbiIsInRva2VuX3R5cGUiLCJyZWZyZXNoX3Rva2VuIiwic2NvcGUiLCJpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiaWRfdG9rZW5fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsInZhbGlkYXRlUHJlc2VuY2UiLCJ2YWxpZGF0ZUlzc3VlciIsInZhbGlkYXRlQXVkaWVuY2UiLCJhenAiLCJyZXF1aXJlX2F1dGhfdGltZSIsImF1dGhfdGltZSIsInByb2Nlc3NSZWZyZXNoVG9rZW5SZXNwb25zZSIsImJyYW5kZWQiLCJXZWFrU2V0IiwiYnJhbmQiLCJzZWFyY2hQYXJhbXMiLCJhZGQiLCJhdXRob3JpemF0aW9uQ29kZUdyYW50UmVxdWVzdCIsImNhbGxiYWNrUGFyYW1ldGVycyIsInJlZGlyZWN0VXJpIiwiY29kZSIsImdldFVSTFNlYXJjaFBhcmFtZXRlciIsImp3dENsYWltTmFtZXMiLCJjX2hhc2giLCJzX2hhc2giLCJjbmYiLCJyZXF1aXJlZCIsImNsYWltIiwiZXhwZWN0Tm9Ob25jZSIsInNraXBBdXRoVGltZUNoZWNrIiwicHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT3BlbklEUmVzcG9uc2UiLCJleHBlY3RlZE5vbmNlIiwibWF4QWdlIiwiZGVmYXVsdF9tYXhfYWdlIiwicHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT0F1dGgyUmVzcG9uc2UiLCJjaGVja0p3dFR5cGUiLCJjbGllbnRDcmVkZW50aWFsc0dyYW50UmVxdWVzdCIsInByb2Nlc3NDbGllbnRDcmVkZW50aWFsc1Jlc3BvbnNlIiwicmV2b2NhdGlvblJlcXVlc3QiLCJwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlIiwiYm9keVVzZWQiLCJpbnRyb3NwZWN0aW9uUmVxdWVzdCIsInJlcXVlc3RKd3RSZXNwb25zZSIsImludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsInByb2Nlc3NJbnRyb3NwZWN0aW9uUmVzcG9uc2UiLCJpbnRyb3NwZWN0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ0b2tlbl9pbnRyb3NwZWN0aW9uIiwiYWN0aXZlIiwiZXZlcnkiLCJjYWxsIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvcl91cmkiLCJhbGdzIiwiY2hlY2tSc2FLZXlBbGdvcml0aG0iLCJtb2R1bHVzTGVuZ3RoIiwiZWNkc2FIYXNoTmFtZSIsInNhbHRMZW5ndGgiLCJwYXJzZUludCIsImp3cyIsImNoZWNrQWxnIiwiZ2V0S2V5IiwicHJvdGVjdGVkSGVhZGVyIiwicGF5bG9hZCIsImVuY29kZWRTaWduYXR1cmUiLCJjcml0IiwidmVyaWZpZWQiLCJ2ZXJpZnkiLCJ2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSIsImV4cGVjdGVkU3RhdGUiLCJqd2tzX3VyaSIsImF1dGhvcml6YXRpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImF1dGhvcml6YXRpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsInZhbGlkYXRlQXV0aFJlc3BvbnNlIiwiaWRUb2tlbkhhc2giLCJkYXRhIiwiaWRUb2tlbkhhc2hNYXRjaGVzIiwiYWN0dWFsIiwiZXhwZXJpbWVudGFsX3ZhbGlkYXRlRGV0YWNoZWRTaWduYXR1cmVSZXNwb25zZSIsImV4cGVjdE5vU3RhdGUiLCJhdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkIiwicmVxdWlyZWRDbGFpbXMiLCJza2lwU3RhdGVDaGVjayIsInN0YXRlIiwiYWxnVG9TdWJ0bGUiLCJleHQiLCJpbXBvcnRLZXkiLCJkZXZpY2VBdXRob3JpemF0aW9uUmVxdWVzdCIsInByb2Nlc3NEZXZpY2VBdXRob3JpemF0aW9uUmVzcG9uc2UiLCJkZXZpY2VfY29kZSIsInVzZXJfY29kZSIsInZlcmlmaWNhdGlvbl91cmkiLCJ2ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlIiwiaW50ZXJ2YWwiLCJkZXZpY2VDb2RlR3JhbnRSZXF1ZXN0IiwiZGV2aWNlQ29kZSIsInByb2Nlc3NEZXZpY2VDb2RlUmVzcG9uc2UiLCJnZW5lcmF0ZUtleVBhaXIiLCJhc3NpZ24iLCJwdWJsaWNFeHBvbmVudCIsImdlbmVyYXRlS2V5Iiwibm9ybWFsaXplSHR1Iiwic2VhcmNoIiwidmFsaWRhdGVEUG9QIiwicmVxdWVzdCIsImFjY2Vzc1Rva2VuQ2xhaW1zIiwiamt0IiwiZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwiZGlmZiIsImFicyIsImNvbXBvbmVudHMiLCJleHBlcmltZW50YWxfdmFsaWRhdGVKd3RBY2Nlc3NUb2tlbiIsImV4cGVjdGVkQXVkaWVuY2UiLCJSZXF1ZXN0IiwiYXV0aG9yaXphdGlvbiIsInJlcXVpcmVEUG9QIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/oauth4webapi/build/index.js\n");

/***/ })

};
;